// Code generated by Prisma (prisma@1.23.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  advantage: (where?: AdvantageWhereInput) => Promise<boolean>;
  advantageIcon: (where?: AdvantageIconWhereInput) => Promise<boolean>;
  area: (where?: AreaWhereInput) => Promise<boolean>;
  booking: (where?: BookingWhereInput) => Promise<boolean>;
  contact: (where?: ContactWhereInput) => Promise<boolean>;
  country: (where?: CountryWhereInput) => Promise<boolean>;
  favorite: (where?: FavoriteWhereInput) => Promise<boolean>;
  hotel: (where?: HotelWhereInput) => Promise<boolean>;
  hotelPhoto: (where?: HotelPhotoWhereInput) => Promise<boolean>;
  post: (where?: PostWhereInput) => Promise<boolean>;
  postCategory: (where?: PostCategoryWhereInput) => Promise<boolean>;
  postHero: (where?: PostHeroWhereInput) => Promise<boolean>;
  postPhotos: (where?: PostPhotosWhereInput) => Promise<boolean>;
  profile: (where?: ProfileWhereInput) => Promise<boolean>;
  review: (where?: ReviewWhereInput) => Promise<boolean>;
  room: (where?: RoomWhereInput) => Promise<boolean>;
  roomPhoto: (where?: RoomPhotoWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userPhoto: (where?: UserPhotoWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  advantage: (where: AdvantageWhereUniqueInput) => AdvantagePromise;
  advantages: (
    args?: {
      where?: AdvantageWhereInput;
      orderBy?: AdvantageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Advantage>;
  advantagesConnection: (
    args?: {
      where?: AdvantageWhereInput;
      orderBy?: AdvantageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AdvantageConnectionPromise;
  advantageIcon: (where: AdvantageIconWhereUniqueInput) => AdvantageIconPromise;
  advantageIcons: (
    args?: {
      where?: AdvantageIconWhereInput;
      orderBy?: AdvantageIconOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<AdvantageIcon>;
  advantageIconsConnection: (
    args?: {
      where?: AdvantageIconWhereInput;
      orderBy?: AdvantageIconOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AdvantageIconConnectionPromise;
  area: (where: AreaWhereUniqueInput) => AreaPromise;
  areas: (
    args?: {
      where?: AreaWhereInput;
      orderBy?: AreaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Area>;
  areasConnection: (
    args?: {
      where?: AreaWhereInput;
      orderBy?: AreaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AreaConnectionPromise;
  booking: (where: BookingWhereUniqueInput) => BookingPromise;
  bookings: (
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Booking>;
  bookingsConnection: (
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BookingConnectionPromise;
  contact: (where: ContactWhereUniqueInput) => ContactPromise;
  contacts: (
    args?: {
      where?: ContactWhereInput;
      orderBy?: ContactOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Contact>;
  contactsConnection: (
    args?: {
      where?: ContactWhereInput;
      orderBy?: ContactOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ContactConnectionPromise;
  country: (where: CountryWhereUniqueInput) => CountryPromise;
  countries: (
    args?: {
      where?: CountryWhereInput;
      orderBy?: CountryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Country>;
  countriesConnection: (
    args?: {
      where?: CountryWhereInput;
      orderBy?: CountryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CountryConnectionPromise;
  favorite: (where: FavoriteWhereUniqueInput) => FavoritePromise;
  favorites: (
    args?: {
      where?: FavoriteWhereInput;
      orderBy?: FavoriteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Favorite>;
  favoritesConnection: (
    args?: {
      where?: FavoriteWhereInput;
      orderBy?: FavoriteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FavoriteConnectionPromise;
  hotel: (where: HotelWhereUniqueInput) => HotelPromise;
  hotels: (
    args?: {
      where?: HotelWhereInput;
      orderBy?: HotelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Hotel>;
  hotelsConnection: (
    args?: {
      where?: HotelWhereInput;
      orderBy?: HotelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HotelConnectionPromise;
  hotelPhoto: (where: HotelPhotoWhereUniqueInput) => HotelPhotoPromise;
  hotelPhotos: (
    args?: {
      where?: HotelPhotoWhereInput;
      orderBy?: HotelPhotoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<HotelPhoto>;
  hotelPhotosConnection: (
    args?: {
      where?: HotelPhotoWhereInput;
      orderBy?: HotelPhotoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HotelPhotoConnectionPromise;
  post: (where: PostWhereUniqueInput) => PostPromise;
  posts: (
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Post>;
  postsConnection: (
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PostConnectionPromise;
  postCategory: (where: PostCategoryWhereUniqueInput) => PostCategoryPromise;
  postCategories: (
    args?: {
      where?: PostCategoryWhereInput;
      orderBy?: PostCategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PostCategory>;
  postCategoriesConnection: (
    args?: {
      where?: PostCategoryWhereInput;
      orderBy?: PostCategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PostCategoryConnectionPromise;
  postHero: (where: PostHeroWhereUniqueInput) => PostHeroPromise;
  postHeroes: (
    args?: {
      where?: PostHeroWhereInput;
      orderBy?: PostHeroOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PostHero>;
  postHeroesConnection: (
    args?: {
      where?: PostHeroWhereInput;
      orderBy?: PostHeroOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PostHeroConnectionPromise;
  postPhotos: (where: PostPhotosWhereUniqueInput) => PostPhotosPromise;
  postPhotoses: (
    args?: {
      where?: PostPhotosWhereInput;
      orderBy?: PostPhotosOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PostPhotos>;
  postPhotosesConnection: (
    args?: {
      where?: PostPhotosWhereInput;
      orderBy?: PostPhotosOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PostPhotosConnectionPromise;
  profile: (where: ProfileWhereUniqueInput) => ProfilePromise;
  profiles: (
    args?: {
      where?: ProfileWhereInput;
      orderBy?: ProfileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Profile>;
  profilesConnection: (
    args?: {
      where?: ProfileWhereInput;
      orderBy?: ProfileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProfileConnectionPromise;
  review: (where: ReviewWhereUniqueInput) => ReviewPromise;
  reviews: (
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Review>;
  reviewsConnection: (
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ReviewConnectionPromise;
  room: (where: RoomWhereUniqueInput) => RoomPromise;
  rooms: (
    args?: {
      where?: RoomWhereInput;
      orderBy?: RoomOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Room>;
  roomsConnection: (
    args?: {
      where?: RoomWhereInput;
      orderBy?: RoomOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RoomConnectionPromise;
  roomPhoto: (where: RoomPhotoWhereUniqueInput) => RoomPhotoPromise;
  roomPhotos: (
    args?: {
      where?: RoomPhotoWhereInput;
      orderBy?: RoomPhotoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<RoomPhoto>;
  roomPhotosConnection: (
    args?: {
      where?: RoomPhotoWhereInput;
      orderBy?: RoomPhotoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RoomPhotoConnectionPromise;
  tag: (where: TagWhereUniqueInput) => TagPromise;
  tags: (
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Tag>;
  tagsConnection: (
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TagConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  userPhoto: (where: UserPhotoWhereUniqueInput) => UserPhotoPromise;
  userPhotos: (
    args?: {
      where?: UserPhotoWhereInput;
      orderBy?: UserPhotoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserPhoto>;
  userPhotosConnection: (
    args?: {
      where?: UserPhotoWhereInput;
      orderBy?: UserPhotoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserPhotoConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAdvantage: (data: AdvantageCreateInput) => AdvantagePromise;
  updateAdvantage: (
    args: { data: AdvantageUpdateInput; where: AdvantageWhereUniqueInput }
  ) => AdvantagePromise;
  updateManyAdvantages: (
    args: {
      data: AdvantageUpdateManyMutationInput;
      where?: AdvantageWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertAdvantage: (
    args: {
      where: AdvantageWhereUniqueInput;
      create: AdvantageCreateInput;
      update: AdvantageUpdateInput;
    }
  ) => AdvantagePromise;
  deleteAdvantage: (where: AdvantageWhereUniqueInput) => AdvantagePromise;
  deleteManyAdvantages: (where?: AdvantageWhereInput) => BatchPayloadPromise;
  createAdvantageIcon: (data: AdvantageIconCreateInput) => AdvantageIconPromise;
  updateAdvantageIcon: (
    args: {
      data: AdvantageIconUpdateInput;
      where: AdvantageIconWhereUniqueInput;
    }
  ) => AdvantageIconPromise;
  updateManyAdvantageIcons: (
    args: {
      data: AdvantageIconUpdateManyMutationInput;
      where?: AdvantageIconWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertAdvantageIcon: (
    args: {
      where: AdvantageIconWhereUniqueInput;
      create: AdvantageIconCreateInput;
      update: AdvantageIconUpdateInput;
    }
  ) => AdvantageIconPromise;
  deleteAdvantageIcon: (
    where: AdvantageIconWhereUniqueInput
  ) => AdvantageIconPromise;
  deleteManyAdvantageIcons: (
    where?: AdvantageIconWhereInput
  ) => BatchPayloadPromise;
  createArea: (data: AreaCreateInput) => AreaPromise;
  updateArea: (
    args: { data: AreaUpdateInput; where: AreaWhereUniqueInput }
  ) => AreaPromise;
  updateManyAreas: (
    args: { data: AreaUpdateManyMutationInput; where?: AreaWhereInput }
  ) => BatchPayloadPromise;
  upsertArea: (
    args: {
      where: AreaWhereUniqueInput;
      create: AreaCreateInput;
      update: AreaUpdateInput;
    }
  ) => AreaPromise;
  deleteArea: (where: AreaWhereUniqueInput) => AreaPromise;
  deleteManyAreas: (where?: AreaWhereInput) => BatchPayloadPromise;
  createBooking: (data: BookingCreateInput) => BookingPromise;
  updateBooking: (
    args: { data: BookingUpdateInput; where: BookingWhereUniqueInput }
  ) => BookingPromise;
  updateManyBookings: (
    args: { data: BookingUpdateManyMutationInput; where?: BookingWhereInput }
  ) => BatchPayloadPromise;
  upsertBooking: (
    args: {
      where: BookingWhereUniqueInput;
      create: BookingCreateInput;
      update: BookingUpdateInput;
    }
  ) => BookingPromise;
  deleteBooking: (where: BookingWhereUniqueInput) => BookingPromise;
  deleteManyBookings: (where?: BookingWhereInput) => BatchPayloadPromise;
  createContact: (data: ContactCreateInput) => ContactPromise;
  updateContact: (
    args: { data: ContactUpdateInput; where: ContactWhereUniqueInput }
  ) => ContactPromise;
  updateManyContacts: (
    args: { data: ContactUpdateManyMutationInput; where?: ContactWhereInput }
  ) => BatchPayloadPromise;
  upsertContact: (
    args: {
      where: ContactWhereUniqueInput;
      create: ContactCreateInput;
      update: ContactUpdateInput;
    }
  ) => ContactPromise;
  deleteContact: (where: ContactWhereUniqueInput) => ContactPromise;
  deleteManyContacts: (where?: ContactWhereInput) => BatchPayloadPromise;
  createCountry: (data: CountryCreateInput) => CountryPromise;
  updateCountry: (
    args: { data: CountryUpdateInput; where: CountryWhereUniqueInput }
  ) => CountryPromise;
  updateManyCountries: (
    args: { data: CountryUpdateManyMutationInput; where?: CountryWhereInput }
  ) => BatchPayloadPromise;
  upsertCountry: (
    args: {
      where: CountryWhereUniqueInput;
      create: CountryCreateInput;
      update: CountryUpdateInput;
    }
  ) => CountryPromise;
  deleteCountry: (where: CountryWhereUniqueInput) => CountryPromise;
  deleteManyCountries: (where?: CountryWhereInput) => BatchPayloadPromise;
  createFavorite: (data: FavoriteCreateInput) => FavoritePromise;
  updateFavorite: (
    args: { data: FavoriteUpdateInput; where: FavoriteWhereUniqueInput }
  ) => FavoritePromise;
  upsertFavorite: (
    args: {
      where: FavoriteWhereUniqueInput;
      create: FavoriteCreateInput;
      update: FavoriteUpdateInput;
    }
  ) => FavoritePromise;
  deleteFavorite: (where: FavoriteWhereUniqueInput) => FavoritePromise;
  deleteManyFavorites: (where?: FavoriteWhereInput) => BatchPayloadPromise;
  createHotel: (data: HotelCreateInput) => HotelPromise;
  updateHotel: (
    args: { data: HotelUpdateInput; where: HotelWhereUniqueInput }
  ) => HotelPromise;
  updateManyHotels: (
    args: { data: HotelUpdateManyMutationInput; where?: HotelWhereInput }
  ) => BatchPayloadPromise;
  upsertHotel: (
    args: {
      where: HotelWhereUniqueInput;
      create: HotelCreateInput;
      update: HotelUpdateInput;
    }
  ) => HotelPromise;
  deleteHotel: (where: HotelWhereUniqueInput) => HotelPromise;
  deleteManyHotels: (where?: HotelWhereInput) => BatchPayloadPromise;
  createHotelPhoto: (data: HotelPhotoCreateInput) => HotelPhotoPromise;
  updateHotelPhoto: (
    args: { data: HotelPhotoUpdateInput; where: HotelPhotoWhereUniqueInput }
  ) => HotelPhotoPromise;
  updateManyHotelPhotos: (
    args: {
      data: HotelPhotoUpdateManyMutationInput;
      where?: HotelPhotoWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertHotelPhoto: (
    args: {
      where: HotelPhotoWhereUniqueInput;
      create: HotelPhotoCreateInput;
      update: HotelPhotoUpdateInput;
    }
  ) => HotelPhotoPromise;
  deleteHotelPhoto: (where: HotelPhotoWhereUniqueInput) => HotelPhotoPromise;
  deleteManyHotelPhotos: (where?: HotelPhotoWhereInput) => BatchPayloadPromise;
  createPost: (data: PostCreateInput) => PostPromise;
  updatePost: (
    args: { data: PostUpdateInput; where: PostWhereUniqueInput }
  ) => PostPromise;
  updateManyPosts: (
    args: { data: PostUpdateManyMutationInput; where?: PostWhereInput }
  ) => BatchPayloadPromise;
  upsertPost: (
    args: {
      where: PostWhereUniqueInput;
      create: PostCreateInput;
      update: PostUpdateInput;
    }
  ) => PostPromise;
  deletePost: (where: PostWhereUniqueInput) => PostPromise;
  deleteManyPosts: (where?: PostWhereInput) => BatchPayloadPromise;
  createPostCategory: (data: PostCategoryCreateInput) => PostCategoryPromise;
  updatePostCategory: (
    args: { data: PostCategoryUpdateInput; where: PostCategoryWhereUniqueInput }
  ) => PostCategoryPromise;
  updateManyPostCategories: (
    args: {
      data: PostCategoryUpdateManyMutationInput;
      where?: PostCategoryWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPostCategory: (
    args: {
      where: PostCategoryWhereUniqueInput;
      create: PostCategoryCreateInput;
      update: PostCategoryUpdateInput;
    }
  ) => PostCategoryPromise;
  deletePostCategory: (
    where: PostCategoryWhereUniqueInput
  ) => PostCategoryPromise;
  deleteManyPostCategories: (
    where?: PostCategoryWhereInput
  ) => BatchPayloadPromise;
  createPostHero: (data: PostHeroCreateInput) => PostHeroPromise;
  updatePostHero: (
    args: { data: PostHeroUpdateInput; where: PostHeroWhereUniqueInput }
  ) => PostHeroPromise;
  updateManyPostHeroes: (
    args: { data: PostHeroUpdateManyMutationInput; where?: PostHeroWhereInput }
  ) => BatchPayloadPromise;
  upsertPostHero: (
    args: {
      where: PostHeroWhereUniqueInput;
      create: PostHeroCreateInput;
      update: PostHeroUpdateInput;
    }
  ) => PostHeroPromise;
  deletePostHero: (where: PostHeroWhereUniqueInput) => PostHeroPromise;
  deleteManyPostHeroes: (where?: PostHeroWhereInput) => BatchPayloadPromise;
  createPostPhotos: (data: PostPhotosCreateInput) => PostPhotosPromise;
  updatePostPhotos: (
    args: { data: PostPhotosUpdateInput; where: PostPhotosWhereUniqueInput }
  ) => PostPhotosPromise;
  updateManyPostPhotoses: (
    args: {
      data: PostPhotosUpdateManyMutationInput;
      where?: PostPhotosWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPostPhotos: (
    args: {
      where: PostPhotosWhereUniqueInput;
      create: PostPhotosCreateInput;
      update: PostPhotosUpdateInput;
    }
  ) => PostPhotosPromise;
  deletePostPhotos: (where: PostPhotosWhereUniqueInput) => PostPhotosPromise;
  deleteManyPostPhotoses: (where?: PostPhotosWhereInput) => BatchPayloadPromise;
  createProfile: (data: ProfileCreateInput) => ProfilePromise;
  updateProfile: (
    args: { data: ProfileUpdateInput; where: ProfileWhereUniqueInput }
  ) => ProfilePromise;
  updateManyProfiles: (
    args: { data: ProfileUpdateManyMutationInput; where?: ProfileWhereInput }
  ) => BatchPayloadPromise;
  upsertProfile: (
    args: {
      where: ProfileWhereUniqueInput;
      create: ProfileCreateInput;
      update: ProfileUpdateInput;
    }
  ) => ProfilePromise;
  deleteProfile: (where: ProfileWhereUniqueInput) => ProfilePromise;
  deleteManyProfiles: (where?: ProfileWhereInput) => BatchPayloadPromise;
  createReview: (data: ReviewCreateInput) => ReviewPromise;
  updateReview: (
    args: { data: ReviewUpdateInput; where: ReviewWhereUniqueInput }
  ) => ReviewPromise;
  updateManyReviews: (
    args: { data: ReviewUpdateManyMutationInput; where?: ReviewWhereInput }
  ) => BatchPayloadPromise;
  upsertReview: (
    args: {
      where: ReviewWhereUniqueInput;
      create: ReviewCreateInput;
      update: ReviewUpdateInput;
    }
  ) => ReviewPromise;
  deleteReview: (where: ReviewWhereUniqueInput) => ReviewPromise;
  deleteManyReviews: (where?: ReviewWhereInput) => BatchPayloadPromise;
  createRoom: (data: RoomCreateInput) => RoomPromise;
  updateRoom: (
    args: { data: RoomUpdateInput; where: RoomWhereUniqueInput }
  ) => RoomPromise;
  updateManyRooms: (
    args: { data: RoomUpdateManyMutationInput; where?: RoomWhereInput }
  ) => BatchPayloadPromise;
  upsertRoom: (
    args: {
      where: RoomWhereUniqueInput;
      create: RoomCreateInput;
      update: RoomUpdateInput;
    }
  ) => RoomPromise;
  deleteRoom: (where: RoomWhereUniqueInput) => RoomPromise;
  deleteManyRooms: (where?: RoomWhereInput) => BatchPayloadPromise;
  createRoomPhoto: (data: RoomPhotoCreateInput) => RoomPhotoPromise;
  updateRoomPhoto: (
    args: { data: RoomPhotoUpdateInput; where: RoomPhotoWhereUniqueInput }
  ) => RoomPhotoPromise;
  updateManyRoomPhotos: (
    args: {
      data: RoomPhotoUpdateManyMutationInput;
      where?: RoomPhotoWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertRoomPhoto: (
    args: {
      where: RoomPhotoWhereUniqueInput;
      create: RoomPhotoCreateInput;
      update: RoomPhotoUpdateInput;
    }
  ) => RoomPhotoPromise;
  deleteRoomPhoto: (where: RoomPhotoWhereUniqueInput) => RoomPhotoPromise;
  deleteManyRoomPhotos: (where?: RoomPhotoWhereInput) => BatchPayloadPromise;
  createTag: (data: TagCreateInput) => TagPromise;
  updateTag: (
    args: { data: TagUpdateInput; where: TagWhereUniqueInput }
  ) => TagPromise;
  updateManyTags: (
    args: { data: TagUpdateManyMutationInput; where?: TagWhereInput }
  ) => BatchPayloadPromise;
  upsertTag: (
    args: {
      where: TagWhereUniqueInput;
      create: TagCreateInput;
      update: TagUpdateInput;
    }
  ) => TagPromise;
  deleteTag: (where: TagWhereUniqueInput) => TagPromise;
  deleteManyTags: (where?: TagWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserPhoto: (data: UserPhotoCreateInput) => UserPhotoPromise;
  updateUserPhoto: (
    args: { data: UserPhotoUpdateInput; where: UserPhotoWhereUniqueInput }
  ) => UserPhotoPromise;
  updateManyUserPhotos: (
    args: {
      data: UserPhotoUpdateManyMutationInput;
      where?: UserPhotoWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertUserPhoto: (
    args: {
      where: UserPhotoWhereUniqueInput;
      create: UserPhotoCreateInput;
      update: UserPhotoUpdateInput;
    }
  ) => UserPhotoPromise;
  deleteUserPhoto: (where: UserPhotoWhereUniqueInput) => UserPhotoPromise;
  deleteManyUserPhotos: (where?: UserPhotoWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  advantage: (
    where?: AdvantageSubscriptionWhereInput
  ) => AdvantageSubscriptionPayloadSubscription;
  advantageIcon: (
    where?: AdvantageIconSubscriptionWhereInput
  ) => AdvantageIconSubscriptionPayloadSubscription;
  area: (
    where?: AreaSubscriptionWhereInput
  ) => AreaSubscriptionPayloadSubscription;
  booking: (
    where?: BookingSubscriptionWhereInput
  ) => BookingSubscriptionPayloadSubscription;
  contact: (
    where?: ContactSubscriptionWhereInput
  ) => ContactSubscriptionPayloadSubscription;
  country: (
    where?: CountrySubscriptionWhereInput
  ) => CountrySubscriptionPayloadSubscription;
  favorite: (
    where?: FavoriteSubscriptionWhereInput
  ) => FavoriteSubscriptionPayloadSubscription;
  hotel: (
    where?: HotelSubscriptionWhereInput
  ) => HotelSubscriptionPayloadSubscription;
  hotelPhoto: (
    where?: HotelPhotoSubscriptionWhereInput
  ) => HotelPhotoSubscriptionPayloadSubscription;
  post: (
    where?: PostSubscriptionWhereInput
  ) => PostSubscriptionPayloadSubscription;
  postCategory: (
    where?: PostCategorySubscriptionWhereInput
  ) => PostCategorySubscriptionPayloadSubscription;
  postHero: (
    where?: PostHeroSubscriptionWhereInput
  ) => PostHeroSubscriptionPayloadSubscription;
  postPhotos: (
    where?: PostPhotosSubscriptionWhereInput
  ) => PostPhotosSubscriptionPayloadSubscription;
  profile: (
    where?: ProfileSubscriptionWhereInput
  ) => ProfileSubscriptionPayloadSubscription;
  review: (
    where?: ReviewSubscriptionWhereInput
  ) => ReviewSubscriptionPayloadSubscription;
  room: (
    where?: RoomSubscriptionWhereInput
  ) => RoomSubscriptionPayloadSubscription;
  roomPhoto: (
    where?: RoomPhotoSubscriptionWhereInput
  ) => RoomPhotoSubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userPhoto: (
    where?: UserPhotoSubscriptionWhereInput
  ) => UserPhotoSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ReviewOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "rating_ASC"
  | "rating_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HotelOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "address_ASC"
  | "address_DESC"
  | "latitude_ASC"
  | "latitude_DESC"
  | "longitude_ASC"
  | "longitude_DESC"
  | "appliances_ASC"
  | "appliances_DESC"
  | "tel_ASC"
  | "tel_DESC"
  | "fax_ASC"
  | "fax_DESC"
  | "email_ASC"
  | "email_DESC"
  | "isPublished_ASC"
  | "isPublished_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ROOM_TYPE = "SUPERIOR" | "DELUXE" | "FAMILY" | "PREMIUM";

export type UserPhotoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "cdnUrl_ASC"
  | "cdnUrl_DESC"
  | "uuid_ASC"
  | "uuid_DESC"
  | "isImage_ASC"
  | "isImage_DESC"
  | "isStored_ASC"
  | "isStored_DESC"
  | "mimeType_ASC"
  | "mimeType_DESC"
  | "size_ASC"
  | "size_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BookingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "isPaid_ASC"
  | "isPaid_DESC"
  | "isConfirmed_ASC"
  | "isConfirmed_DESC"
  | "checkIn_ASC"
  | "checkIn_DESC"
  | "checkOut_ASC"
  | "checkOut_DESC"
  | "qty_ASC"
  | "qty_DESC"
  | "nights_ASC"
  | "nights_DESC"
  | "totalAmount_ASC"
  | "totalAmount_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProfileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "passportNo_ASC"
  | "passportNo_DESC"
  | "address_ASC"
  | "address_DESC"
  | "tel_ASC"
  | "tel_DESC"
  | "subscriptionEmail_ASC"
  | "subscriptionEmail_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TagOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "color_ASC"
  | "color_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PostHeroOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "cdnUrl_ASC"
  | "cdnUrl_DESC"
  | "uuid_ASC"
  | "uuid_DESC"
  | "isImage_ASC"
  | "isImage_DESC"
  | "isStored_ASC"
  | "isStored_DESC"
  | "mimeType_ASC"
  | "mimeType_DESC"
  | "size_ASC"
  | "size_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PostCategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "isRoot_ASC"
  | "isRoot_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CountryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "code_ASC"
  | "code_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ROLE = "ADMIN" | "STAFF" | "USER";

export type AdvantageIconOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "cdnUrl_ASC"
  | "cdnUrl_DESC"
  | "uuid_ASC"
  | "uuid_DESC"
  | "isImage_ASC"
  | "isImage_DESC"
  | "isStored_ASC"
  | "isStored_DESC"
  | "mimeType_ASC"
  | "mimeType_DESC"
  | "size_ASC"
  | "size_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PostOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "mdContents_ASC"
  | "mdContents_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AreaOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "code_ASC"
  | "code_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RoomOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "roomType_ASC"
  | "roomType_DESC"
  | "price_ASC"
  | "price_DESC"
  | "people_ASC"
  | "people_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RoomPhotoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "cdnUrl_ASC"
  | "cdnUrl_DESC"
  | "uuid_ASC"
  | "uuid_DESC"
  | "count_ASC"
  | "count_DESC"
  | "isImage_ASC"
  | "isImage_DESC"
  | "isStored_ASC"
  | "isStored_DESC"
  | "size_ASC"
  | "size_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FavoriteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "auth0UserId_ASC"
  | "auth0UserId_DESC"
  | "omiseCustomerId_ASC"
  | "omiseCustomerId_DESC"
  | "role_ASC"
  | "role_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AdvantageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "iconName_ASC"
  | "iconName_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ContactOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "tel_ASC"
  | "tel_DESC"
  | "title_ASC"
  | "title_DESC"
  | "reference_ASC"
  | "reference_DESC"
  | "description_ASC"
  | "description_DESC"
  | "isReplied_ASC"
  | "isReplied_DESC"
  | "replyMessage_ASC"
  | "replyMessage_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HotelPhotoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "cdnUrl_ASC"
  | "cdnUrl_DESC"
  | "uuid_ASC"
  | "uuid_DESC"
  | "count_ASC"
  | "count_DESC"
  | "isImage_ASC"
  | "isImage_DESC"
  | "isStored_ASC"
  | "isStored_DESC"
  | "size_ASC"
  | "size_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PostPhotosOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "cdnUrl_ASC"
  | "cdnUrl_DESC"
  | "uuid_ASC"
  | "uuid_DESC"
  | "count_ASC"
  | "count_DESC"
  | "isImage_ASC"
  | "isImage_DESC"
  | "isStored_ASC"
  | "isStored_DESC"
  | "size_ASC"
  | "size_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface PostUpdateManyWithoutCategoryInput {
  create?: PostCreateWithoutCategoryInput[] | PostCreateWithoutCategoryInput;
  delete?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  connect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  disconnect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  update?:
    | PostUpdateWithWhereUniqueWithoutCategoryInput[]
    | PostUpdateWithWhereUniqueWithoutCategoryInput;
  upsert?:
    | PostUpsertWithWhereUniqueWithoutCategoryInput[]
    | PostUpsertWithWhereUniqueWithoutCategoryInput;
  deleteMany?: PostScalarWhereInput[] | PostScalarWhereInput;
  updateMany?:
    | PostUpdateManyWithWhereNestedInput[]
    | PostUpdateManyWithWhereNestedInput;
}

export type AdvantageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface AreaUpdateOneRequiredWithoutHotelsInput {
  create?: AreaCreateWithoutHotelsInput;
  update?: AreaUpdateWithoutHotelsDataInput;
  upsert?: AreaUpsertWithoutHotelsInput;
  connect?: AreaWhereUniqueInput;
}

export interface ProfileWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  passportNo?: String;
  passportNo_not?: String;
  passportNo_in?: String[] | String;
  passportNo_not_in?: String[] | String;
  passportNo_lt?: String;
  passportNo_lte?: String;
  passportNo_gt?: String;
  passportNo_gte?: String;
  passportNo_contains?: String;
  passportNo_not_contains?: String;
  passportNo_starts_with?: String;
  passportNo_not_starts_with?: String;
  passportNo_ends_with?: String;
  passportNo_not_ends_with?: String;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  tel?: String;
  tel_not?: String;
  tel_in?: String[] | String;
  tel_not_in?: String[] | String;
  tel_lt?: String;
  tel_lte?: String;
  tel_gt?: String;
  tel_gte?: String;
  tel_contains?: String;
  tel_not_contains?: String;
  tel_starts_with?: String;
  tel_not_starts_with?: String;
  tel_ends_with?: String;
  tel_not_ends_with?: String;
  subscriptionEmail?: String;
  subscriptionEmail_not?: String;
  subscriptionEmail_in?: String[] | String;
  subscriptionEmail_not_in?: String[] | String;
  subscriptionEmail_lt?: String;
  subscriptionEmail_lte?: String;
  subscriptionEmail_gt?: String;
  subscriptionEmail_gte?: String;
  subscriptionEmail_contains?: String;
  subscriptionEmail_not_contains?: String;
  subscriptionEmail_starts_with?: String;
  subscriptionEmail_not_starts_with?: String;
  subscriptionEmail_ends_with?: String;
  subscriptionEmail_not_ends_with?: String;
  user?: UserWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ProfileWhereInput[] | ProfileWhereInput;
  OR?: ProfileWhereInput[] | ProfileWhereInput;
  NOT?: ProfileWhereInput[] | ProfileWhereInput;
}

export interface AreaUpdateWithoutHotelsDataInput {
  name?: String;
  code?: String;
  slug?: String;
  country?: CountryUpdateOneRequiredWithoutAreasInput;
}

export interface ReviewWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  rating?: Float;
  rating_not?: Float;
  rating_in?: Float[] | Float;
  rating_not_in?: Float[] | Float;
  rating_lt?: Float;
  rating_lte?: Float;
  rating_gt?: Float;
  rating_gte?: Float;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  hotel?: HotelWhereInput;
  user?: UserWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ReviewWhereInput[] | ReviewWhereInput;
  OR?: ReviewWhereInput[] | ReviewWhereInput;
  NOT?: ReviewWhereInput[] | ReviewWhereInput;
}

export interface CountryUpdateOneRequiredWithoutAreasInput {
  create?: CountryCreateWithoutAreasInput;
  update?: CountryUpdateWithoutAreasDataInput;
  upsert?: CountryUpsertWithoutAreasInput;
  connect?: CountryWhereUniqueInput;
}

export interface AdvantageIconWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  cdnUrl?: String;
  cdnUrl_not?: String;
  cdnUrl_in?: String[] | String;
  cdnUrl_not_in?: String[] | String;
  cdnUrl_lt?: String;
  cdnUrl_lte?: String;
  cdnUrl_gt?: String;
  cdnUrl_gte?: String;
  cdnUrl_contains?: String;
  cdnUrl_not_contains?: String;
  cdnUrl_starts_with?: String;
  cdnUrl_not_starts_with?: String;
  cdnUrl_ends_with?: String;
  cdnUrl_not_ends_with?: String;
  uuid?: String;
  uuid_not?: String;
  uuid_in?: String[] | String;
  uuid_not_in?: String[] | String;
  uuid_lt?: String;
  uuid_lte?: String;
  uuid_gt?: String;
  uuid_gte?: String;
  uuid_contains?: String;
  uuid_not_contains?: String;
  uuid_starts_with?: String;
  uuid_not_starts_with?: String;
  uuid_ends_with?: String;
  uuid_not_ends_with?: String;
  isImage?: Boolean;
  isImage_not?: Boolean;
  isStored?: Boolean;
  isStored_not?: Boolean;
  mimeType?: String;
  mimeType_not?: String;
  mimeType_in?: String[] | String;
  mimeType_not_in?: String[] | String;
  mimeType_lt?: String;
  mimeType_lte?: String;
  mimeType_gt?: String;
  mimeType_gte?: String;
  mimeType_contains?: String;
  mimeType_not_contains?: String;
  mimeType_starts_with?: String;
  mimeType_not_starts_with?: String;
  mimeType_ends_with?: String;
  mimeType_not_ends_with?: String;
  size?: Int;
  size_not?: Int;
  size_in?: Int[] | Int;
  size_not_in?: Int[] | Int;
  size_lt?: Int;
  size_lte?: Int;
  size_gt?: Int;
  size_gte?: Int;
  advantage?: AdvantageWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: AdvantageIconWhereInput[] | AdvantageIconWhereInput;
  OR?: AdvantageIconWhereInput[] | AdvantageIconWhereInput;
  NOT?: AdvantageIconWhereInput[] | AdvantageIconWhereInput;
}

export interface AdvantageUpdateInput {
  name?: String;
  iconName?: String;
  icon?: AdvantageIconUpdateOneWithoutAdvantageInput;
  hotels?: HotelUpdateManyWithoutAdvantagesInput;
}

export interface PostCreateInput {
  title: String;
  mdContents: String;
  author: UserCreateOneWithoutPostsInput;
  category?: PostCategoryCreateOneWithoutPostsInput;
  tags?: TagCreateManyWithoutPostsInput;
  hero?: PostHeroCreateOneWithoutPostInput;
  photos?: PostPhotosCreateOneWithoutPostInput;
}

export interface AdvantageIconUpdateOneWithoutAdvantageInput {
  create?: AdvantageIconCreateWithoutAdvantageInput;
  update?: AdvantageIconUpdateWithoutAdvantageDataInput;
  upsert?: AdvantageIconUpsertWithoutAdvantageInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: AdvantageIconWhereUniqueInput;
}

export interface CountryUpdateWithoutAreasDataInput {
  name?: String;
  code?: String;
  slug?: String;
  hotels?: HotelUpdateManyWithoutCountryInput;
}

export interface AdvantageIconUpdateWithoutAdvantageDataInput {
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  isImage?: Boolean;
  isStored?: Boolean;
  mimeType?: String;
  size?: Int;
}

export interface UserPhotoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserPhotoWhereInput;
  AND?: UserPhotoSubscriptionWhereInput[] | UserPhotoSubscriptionWhereInput;
  OR?: UserPhotoSubscriptionWhereInput[] | UserPhotoSubscriptionWhereInput;
  NOT?: UserPhotoSubscriptionWhereInput[] | UserPhotoSubscriptionWhereInput;
}

export interface AdvantageIconUpsertWithoutAdvantageInput {
  update: AdvantageIconUpdateWithoutAdvantageDataInput;
  create: AdvantageIconCreateWithoutAdvantageInput;
}

export interface TagWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  color?: String;
  color_not?: String;
  color_in?: String[] | String;
  color_not_in?: String[] | String;
  color_lt?: String;
  color_lte?: String;
  color_gt?: String;
  color_gte?: String;
  color_contains?: String;
  color_not_contains?: String;
  color_starts_with?: String;
  color_not_starts_with?: String;
  color_ends_with?: String;
  color_not_ends_with?: String;
  posts_every?: PostWhereInput;
  posts_some?: PostWhereInput;
  posts_none?: PostWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: TagWhereInput[] | TagWhereInput;
  OR?: TagWhereInput[] | TagWhereInput;
  NOT?: TagWhereInput[] | TagWhereInput;
}

export interface HotelUpdateManyWithoutAdvantagesInput {
  create?:
    | HotelCreateWithoutAdvantagesInput[]
    | HotelCreateWithoutAdvantagesInput;
  delete?: HotelWhereUniqueInput[] | HotelWhereUniqueInput;
  connect?: HotelWhereUniqueInput[] | HotelWhereUniqueInput;
  disconnect?: HotelWhereUniqueInput[] | HotelWhereUniqueInput;
  update?:
    | HotelUpdateWithWhereUniqueWithoutAdvantagesInput[]
    | HotelUpdateWithWhereUniqueWithoutAdvantagesInput;
  upsert?:
    | HotelUpsertWithWhereUniqueWithoutAdvantagesInput[]
    | HotelUpsertWithWhereUniqueWithoutAdvantagesInput;
  deleteMany?: HotelScalarWhereInput[] | HotelScalarWhereInput;
  updateMany?:
    | HotelUpdateManyWithWhereNestedInput[]
    | HotelUpdateManyWithWhereNestedInput;
}

export interface PostCategoryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  isRoot?: Boolean;
  isRoot_not?: Boolean;
  posts_every?: PostWhereInput;
  posts_some?: PostWhereInput;
  posts_none?: PostWhereInput;
  children_every?: PostCategoryWhereInput;
  children_some?: PostCategoryWhereInput;
  children_none?: PostCategoryWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: PostCategoryWhereInput[] | PostCategoryWhereInput;
  OR?: PostCategoryWhereInput[] | PostCategoryWhereInput;
  NOT?: PostCategoryWhereInput[] | PostCategoryWhereInput;
}

export interface HotelUpdateWithWhereUniqueWithoutAdvantagesInput {
  where: HotelWhereUniqueInput;
  data: HotelUpdateWithoutAdvantagesDataInput;
}

export interface PostWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  mdContents?: String;
  mdContents_not?: String;
  mdContents_in?: String[] | String;
  mdContents_not_in?: String[] | String;
  mdContents_lt?: String;
  mdContents_lte?: String;
  mdContents_gt?: String;
  mdContents_gte?: String;
  mdContents_contains?: String;
  mdContents_not_contains?: String;
  mdContents_starts_with?: String;
  mdContents_not_starts_with?: String;
  mdContents_ends_with?: String;
  mdContents_not_ends_with?: String;
  author?: UserWhereInput;
  category?: PostCategoryWhereInput;
  tags_every?: TagWhereInput;
  tags_some?: TagWhereInput;
  tags_none?: TagWhereInput;
  hero?: PostHeroWhereInput;
  photos?: PostPhotosWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: PostWhereInput[] | PostWhereInput;
  OR?: PostWhereInput[] | PostWhereInput;
  NOT?: PostWhereInput[] | PostWhereInput;
}

export interface HotelUpdateWithoutAdvantagesDataInput {
  name?: String;
  address?: String;
  latitude?: Float;
  longitude?: Float;
  appliances?: String;
  tel?: String;
  fax?: String;
  email?: String;
  isPublished?: Boolean;
  country?: CountryUpdateOneRequiredWithoutHotelsInput;
  area?: AreaUpdateOneRequiredWithoutHotelsInput;
  photos?: HotelPhotoUpdateOneWithoutHotelInput;
  rooms?: RoomUpdateManyWithoutHotelInput;
  favorites?: FavoriteUpdateManyWithoutHotelsInput;
  bookings?: BookingUpdateManyWithoutHotelInput;
  reviews?: ReviewUpdateManyWithoutHotelInput;
}

export interface ReviewSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ReviewWhereInput;
  AND?: ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput;
  OR?: ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput;
  NOT?: ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput;
}

export interface CountryUpdateOneRequiredWithoutHotelsInput {
  create?: CountryCreateWithoutHotelsInput;
  update?: CountryUpdateWithoutHotelsDataInput;
  upsert?: CountryUpsertWithoutHotelsInput;
  connect?: CountryWhereUniqueInput;
}

export interface UserPhotoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  cdnUrl?: String;
  cdnUrl_not?: String;
  cdnUrl_in?: String[] | String;
  cdnUrl_not_in?: String[] | String;
  cdnUrl_lt?: String;
  cdnUrl_lte?: String;
  cdnUrl_gt?: String;
  cdnUrl_gte?: String;
  cdnUrl_contains?: String;
  cdnUrl_not_contains?: String;
  cdnUrl_starts_with?: String;
  cdnUrl_not_starts_with?: String;
  cdnUrl_ends_with?: String;
  cdnUrl_not_ends_with?: String;
  uuid?: String;
  uuid_not?: String;
  uuid_in?: String[] | String;
  uuid_not_in?: String[] | String;
  uuid_lt?: String;
  uuid_lte?: String;
  uuid_gt?: String;
  uuid_gte?: String;
  uuid_contains?: String;
  uuid_not_contains?: String;
  uuid_starts_with?: String;
  uuid_not_starts_with?: String;
  uuid_ends_with?: String;
  uuid_not_ends_with?: String;
  isImage?: Boolean;
  isImage_not?: Boolean;
  isStored?: Boolean;
  isStored_not?: Boolean;
  mimeType?: String;
  mimeType_not?: String;
  mimeType_in?: String[] | String;
  mimeType_not_in?: String[] | String;
  mimeType_lt?: String;
  mimeType_lte?: String;
  mimeType_gt?: String;
  mimeType_gte?: String;
  mimeType_contains?: String;
  mimeType_not_contains?: String;
  mimeType_starts_with?: String;
  mimeType_not_starts_with?: String;
  mimeType_ends_with?: String;
  mimeType_not_ends_with?: String;
  size?: Int;
  size_not?: Int;
  size_in?: Int[] | Int;
  size_not_in?: Int[] | Int;
  size_lt?: Int;
  size_lte?: Int;
  size_gt?: Int;
  size_gte?: Int;
  user?: UserWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: UserPhotoWhereInput[] | UserPhotoWhereInput;
  OR?: UserPhotoWhereInput[] | UserPhotoWhereInput;
  NOT?: UserPhotoWhereInput[] | UserPhotoWhereInput;
}

export interface CountryUpdateWithoutHotelsDataInput {
  name?: String;
  code?: String;
  slug?: String;
  areas?: AreaUpdateManyWithoutCountryInput;
}

export interface PostHeroSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PostHeroWhereInput;
  AND?: PostHeroSubscriptionWhereInput[] | PostHeroSubscriptionWhereInput;
  OR?: PostHeroSubscriptionWhereInput[] | PostHeroSubscriptionWhereInput;
  NOT?: PostHeroSubscriptionWhereInput[] | PostHeroSubscriptionWhereInput;
}

export interface AreaUpdateManyWithoutCountryInput {
  create?: AreaCreateWithoutCountryInput[] | AreaCreateWithoutCountryInput;
  delete?: AreaWhereUniqueInput[] | AreaWhereUniqueInput;
  connect?: AreaWhereUniqueInput[] | AreaWhereUniqueInput;
  disconnect?: AreaWhereUniqueInput[] | AreaWhereUniqueInput;
  update?:
    | AreaUpdateWithWhereUniqueWithoutCountryInput[]
    | AreaUpdateWithWhereUniqueWithoutCountryInput;
  upsert?:
    | AreaUpsertWithWhereUniqueWithoutCountryInput[]
    | AreaUpsertWithWhereUniqueWithoutCountryInput;
  deleteMany?: AreaScalarWhereInput[] | AreaScalarWhereInput;
  updateMany?:
    | AreaUpdateManyWithWhereNestedInput[]
    | AreaUpdateManyWithWhereNestedInput;
}

export interface FavoriteWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  hotels?: HotelWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: FavoriteWhereInput[] | FavoriteWhereInput;
  OR?: FavoriteWhereInput[] | FavoriteWhereInput;
  NOT?: FavoriteWhereInput[] | FavoriteWhereInput;
}

export interface AreaUpdateWithWhereUniqueWithoutCountryInput {
  where: AreaWhereUniqueInput;
  data: AreaUpdateWithoutCountryDataInput;
}

export interface PostSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PostWhereInput;
  AND?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
  OR?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
  NOT?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
}

export interface AreaUpdateWithoutCountryDataInput {
  name?: String;
  code?: String;
  slug?: String;
  hotels?: HotelUpdateManyWithoutAreaInput;
}

export interface HotelSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HotelWhereInput;
  AND?: HotelSubscriptionWhereInput[] | HotelSubscriptionWhereInput;
  OR?: HotelSubscriptionWhereInput[] | HotelSubscriptionWhereInput;
  NOT?: HotelSubscriptionWhereInput[] | HotelSubscriptionWhereInput;
}

export interface HotelUpdateManyWithoutAreaInput {
  create?: HotelCreateWithoutAreaInput[] | HotelCreateWithoutAreaInput;
  delete?: HotelWhereUniqueInput[] | HotelWhereUniqueInput;
  connect?: HotelWhereUniqueInput[] | HotelWhereUniqueInput;
  disconnect?: HotelWhereUniqueInput[] | HotelWhereUniqueInput;
  update?:
    | HotelUpdateWithWhereUniqueWithoutAreaInput[]
    | HotelUpdateWithWhereUniqueWithoutAreaInput;
  upsert?:
    | HotelUpsertWithWhereUniqueWithoutAreaInput[]
    | HotelUpsertWithWhereUniqueWithoutAreaInput;
  deleteMany?: HotelScalarWhereInput[] | HotelScalarWhereInput;
  updateMany?:
    | HotelUpdateManyWithWhereNestedInput[]
    | HotelUpdateManyWithWhereNestedInput;
}

export interface FavoriteSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FavoriteWhereInput;
  AND?: FavoriteSubscriptionWhereInput[] | FavoriteSubscriptionWhereInput;
  OR?: FavoriteSubscriptionWhereInput[] | FavoriteSubscriptionWhereInput;
  NOT?: FavoriteSubscriptionWhereInput[] | FavoriteSubscriptionWhereInput;
}

export interface HotelUpdateWithWhereUniqueWithoutAreaInput {
  where: HotelWhereUniqueInput;
  data: HotelUpdateWithoutAreaDataInput;
}

export interface CountrySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CountryWhereInput;
  AND?: CountrySubscriptionWhereInput[] | CountrySubscriptionWhereInput;
  OR?: CountrySubscriptionWhereInput[] | CountrySubscriptionWhereInput;
  NOT?: CountrySubscriptionWhereInput[] | CountrySubscriptionWhereInput;
}

export interface HotelUpdateWithoutAreaDataInput {
  name?: String;
  address?: String;
  latitude?: Float;
  longitude?: Float;
  appliances?: String;
  tel?: String;
  fax?: String;
  email?: String;
  isPublished?: Boolean;
  country?: CountryUpdateOneRequiredWithoutHotelsInput;
  photos?: HotelPhotoUpdateOneWithoutHotelInput;
  rooms?: RoomUpdateManyWithoutHotelInput;
  favorites?: FavoriteUpdateManyWithoutHotelsInput;
  advantages?: AdvantageUpdateManyWithoutHotelsInput;
  bookings?: BookingUpdateManyWithoutHotelInput;
  reviews?: ReviewUpdateManyWithoutHotelInput;
}

export interface ContactSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ContactWhereInput;
  AND?: ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput;
  OR?: ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput;
  NOT?: ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput;
}

export interface HotelPhotoUpdateOneWithoutHotelInput {
  create?: HotelPhotoCreateWithoutHotelInput;
  update?: HotelPhotoUpdateWithoutHotelDataInput;
  upsert?: HotelPhotoUpsertWithoutHotelInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: HotelPhotoWhereUniqueInput;
}

export interface AreaSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AreaWhereInput;
  AND?: AreaSubscriptionWhereInput[] | AreaSubscriptionWhereInput;
  OR?: AreaSubscriptionWhereInput[] | AreaSubscriptionWhereInput;
  NOT?: AreaSubscriptionWhereInput[] | AreaSubscriptionWhereInput;
}

export interface HotelPhotoUpdateWithoutHotelDataInput {
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  count?: Int;
  isImage?: Boolean;
  isStored?: Boolean;
  size?: Int;
}

export type AdvantageIconWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface HotelPhotoUpsertWithoutHotelInput {
  update: HotelPhotoUpdateWithoutHotelDataInput;
  create: HotelPhotoCreateWithoutHotelInput;
}

export interface AdvantageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AdvantageWhereInput;
  AND?: AdvantageSubscriptionWhereInput[] | AdvantageSubscriptionWhereInput;
  OR?: AdvantageSubscriptionWhereInput[] | AdvantageSubscriptionWhereInput;
  NOT?: AdvantageSubscriptionWhereInput[] | AdvantageSubscriptionWhereInput;
}

export interface RoomUpdateManyWithoutHotelInput {
  create?: RoomCreateWithoutHotelInput[] | RoomCreateWithoutHotelInput;
  delete?: RoomWhereUniqueInput[] | RoomWhereUniqueInput;
  connect?: RoomWhereUniqueInput[] | RoomWhereUniqueInput;
  disconnect?: RoomWhereUniqueInput[] | RoomWhereUniqueInput;
  update?:
    | RoomUpdateWithWhereUniqueWithoutHotelInput[]
    | RoomUpdateWithWhereUniqueWithoutHotelInput;
  upsert?:
    | RoomUpsertWithWhereUniqueWithoutHotelInput[]
    | RoomUpsertWithWhereUniqueWithoutHotelInput;
  deleteMany?: RoomScalarWhereInput[] | RoomScalarWhereInput;
  updateMany?:
    | RoomUpdateManyWithWhereNestedInput[]
    | RoomUpdateManyWithWhereNestedInput;
}

export interface UserUpsertWithoutAvatarInput {
  update: UserUpdateWithoutAvatarDataInput;
  create: UserCreateWithoutAvatarInput;
}

export interface RoomUpdateWithWhereUniqueWithoutHotelInput {
  where: RoomWhereUniqueInput;
  data: RoomUpdateWithoutHotelDataInput;
}

export interface UserUpdateWithoutAvatarDataInput {
  email?: String;
  auth0UserId?: String;
  omiseCustomerId?: String;
  role?: ROLE;
  posts?: PostUpdateManyWithoutAuthorInput;
  profile?: ProfileUpdateOneWithoutUserInput;
  favorites?: FavoriteUpdateManyWithoutUserInput;
  bookings?: BookingUpdateManyWithoutUserInput;
  reviews?: ReviewUpdateManyWithoutUserInput;
}

export interface RoomUpdateWithoutHotelDataInput {
  name?: String;
  roomType?: ROOM_TYPE;
  price?: Float;
  people?: Int;
  photos?: RoomPhotoUpdateManyWithoutRoomInput;
}

export interface UserPhotoUpdateInput {
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  isImage?: Boolean;
  isStored?: Boolean;
  mimeType?: String;
  size?: Int;
  user?: UserUpdateOneRequiredWithoutAvatarInput;
}

export interface RoomPhotoUpdateManyWithoutRoomInput {
  create?: RoomPhotoCreateWithoutRoomInput[] | RoomPhotoCreateWithoutRoomInput;
  delete?: RoomPhotoWhereUniqueInput[] | RoomPhotoWhereUniqueInput;
  connect?: RoomPhotoWhereUniqueInput[] | RoomPhotoWhereUniqueInput;
  disconnect?: RoomPhotoWhereUniqueInput[] | RoomPhotoWhereUniqueInput;
  update?:
    | RoomPhotoUpdateWithWhereUniqueWithoutRoomInput[]
    | RoomPhotoUpdateWithWhereUniqueWithoutRoomInput;
  upsert?:
    | RoomPhotoUpsertWithWhereUniqueWithoutRoomInput[]
    | RoomPhotoUpsertWithWhereUniqueWithoutRoomInput;
  deleteMany?: RoomPhotoScalarWhereInput[] | RoomPhotoScalarWhereInput;
  updateMany?:
    | RoomPhotoUpdateManyWithWhereNestedInput[]
    | RoomPhotoUpdateManyWithWhereNestedInput;
}

export interface UserCreateWithoutAvatarInput {
  email?: String;
  auth0UserId?: String;
  omiseCustomerId?: String;
  role?: ROLE;
  posts?: PostCreateManyWithoutAuthorInput;
  profile?: ProfileCreateOneWithoutUserInput;
  favorites?: FavoriteCreateManyWithoutUserInput;
  bookings?: BookingCreateManyWithoutUserInput;
  reviews?: ReviewCreateManyWithoutUserInput;
}

export interface RoomPhotoUpdateWithWhereUniqueWithoutRoomInput {
  where: RoomPhotoWhereUniqueInput;
  data: RoomPhotoUpdateWithoutRoomDataInput;
}

export interface UserPhotoCreateInput {
  name: String;
  cdnUrl: String;
  uuid: String;
  isImage: Boolean;
  isStored: Boolean;
  mimeType: String;
  size: Int;
  user: UserCreateOneWithoutAvatarInput;
}

export interface RoomPhotoUpdateWithoutRoomDataInput {
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  count?: Int;
  isImage?: Boolean;
  isStored?: Boolean;
  size?: Int;
}

export interface UserUpdateManyMutationInput {
  email?: String;
  auth0UserId?: String;
  omiseCustomerId?: String;
  role?: ROLE;
}

export interface RoomPhotoUpsertWithWhereUniqueWithoutRoomInput {
  where: RoomPhotoWhereUniqueInput;
  update: RoomPhotoUpdateWithoutRoomDataInput;
  create: RoomPhotoCreateWithoutRoomInput;
}

export interface CountryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  areas_every?: AreaWhereInput;
  areas_some?: AreaWhereInput;
  areas_none?: AreaWhereInput;
  hotels_every?: HotelWhereInput;
  hotels_some?: HotelWhereInput;
  hotels_none?: HotelWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: CountryWhereInput[] | CountryWhereInput;
  OR?: CountryWhereInput[] | CountryWhereInput;
  NOT?: CountryWhereInput[] | CountryWhereInput;
}

export interface RoomPhotoScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  cdnUrl?: String;
  cdnUrl_not?: String;
  cdnUrl_in?: String[] | String;
  cdnUrl_not_in?: String[] | String;
  cdnUrl_lt?: String;
  cdnUrl_lte?: String;
  cdnUrl_gt?: String;
  cdnUrl_gte?: String;
  cdnUrl_contains?: String;
  cdnUrl_not_contains?: String;
  cdnUrl_starts_with?: String;
  cdnUrl_not_starts_with?: String;
  cdnUrl_ends_with?: String;
  cdnUrl_not_ends_with?: String;
  uuid?: String;
  uuid_not?: String;
  uuid_in?: String[] | String;
  uuid_not_in?: String[] | String;
  uuid_lt?: String;
  uuid_lte?: String;
  uuid_gt?: String;
  uuid_gte?: String;
  uuid_contains?: String;
  uuid_not_contains?: String;
  uuid_starts_with?: String;
  uuid_not_starts_with?: String;
  uuid_ends_with?: String;
  uuid_not_ends_with?: String;
  count?: Int;
  count_not?: Int;
  count_in?: Int[] | Int;
  count_not_in?: Int[] | Int;
  count_lt?: Int;
  count_lte?: Int;
  count_gt?: Int;
  count_gte?: Int;
  isImage?: Boolean;
  isImage_not?: Boolean;
  isStored?: Boolean;
  isStored_not?: Boolean;
  size?: Int;
  size_not?: Int;
  size_in?: Int[] | Int;
  size_not_in?: Int[] | Int;
  size_lt?: Int;
  size_lte?: Int;
  size_gt?: Int;
  size_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: RoomPhotoScalarWhereInput[] | RoomPhotoScalarWhereInput;
  OR?: RoomPhotoScalarWhereInput[] | RoomPhotoScalarWhereInput;
  NOT?: RoomPhotoScalarWhereInput[] | RoomPhotoScalarWhereInput;
}

export interface UserCreateInput {
  email?: String;
  auth0UserId?: String;
  omiseCustomerId?: String;
  role?: ROLE;
  avatar?: UserPhotoCreateOneWithoutUserInput;
  posts?: PostCreateManyWithoutAuthorInput;
  profile?: ProfileCreateOneWithoutUserInput;
  favorites?: FavoriteCreateManyWithoutUserInput;
  bookings?: BookingCreateManyWithoutUserInput;
  reviews?: ReviewCreateManyWithoutUserInput;
}

export interface RoomPhotoUpdateManyWithWhereNestedInput {
  where: RoomPhotoScalarWhereInput;
  data: RoomPhotoUpdateManyDataInput;
}

export type CountryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
  code?: String;
  slug?: String;
}>;

export interface RoomPhotoUpdateManyDataInput {
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  count?: Int;
  isImage?: Boolean;
  isStored?: Boolean;
  size?: Int;
}

export interface PostUpdateWithoutTagsDataInput {
  title?: String;
  mdContents?: String;
  author?: UserUpdateOneRequiredWithoutPostsInput;
  category?: PostCategoryUpdateOneWithoutPostsInput;
  hero?: PostHeroUpdateOneWithoutPostInput;
  photos?: PostPhotosUpdateOneWithoutPostInput;
}

export interface RoomUpsertWithWhereUniqueWithoutHotelInput {
  where: RoomWhereUniqueInput;
  update: RoomUpdateWithoutHotelDataInput;
  create: RoomCreateWithoutHotelInput;
}

export interface PostUpdateManyWithoutTagsInput {
  create?: PostCreateWithoutTagsInput[] | PostCreateWithoutTagsInput;
  delete?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  connect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  disconnect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  update?:
    | PostUpdateWithWhereUniqueWithoutTagsInput[]
    | PostUpdateWithWhereUniqueWithoutTagsInput;
  upsert?:
    | PostUpsertWithWhereUniqueWithoutTagsInput[]
    | PostUpsertWithWhereUniqueWithoutTagsInput;
  deleteMany?: PostScalarWhereInput[] | PostScalarWhereInput;
  updateMany?:
    | PostUpdateManyWithWhereNestedInput[]
    | PostUpdateManyWithWhereNestedInput;
}

export interface RoomScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  roomType?: ROOM_TYPE;
  roomType_not?: ROOM_TYPE;
  roomType_in?: ROOM_TYPE[] | ROOM_TYPE;
  roomType_not_in?: ROOM_TYPE[] | ROOM_TYPE;
  price?: Float;
  price_not?: Float;
  price_in?: Float[] | Float;
  price_not_in?: Float[] | Float;
  price_lt?: Float;
  price_lte?: Float;
  price_gt?: Float;
  price_gte?: Float;
  people?: Int;
  people_not?: Int;
  people_in?: Int[] | Int;
  people_not_in?: Int[] | Int;
  people_lt?: Int;
  people_lte?: Int;
  people_gt?: Int;
  people_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: RoomScalarWhereInput[] | RoomScalarWhereInput;
  OR?: RoomScalarWhereInput[] | RoomScalarWhereInput;
  NOT?: RoomScalarWhereInput[] | RoomScalarWhereInput;
}

export interface TagUpdateInput {
  name?: String;
  color?: String;
  posts?: PostUpdateManyWithoutTagsInput;
}

export interface RoomUpdateManyWithWhereNestedInput {
  where: RoomScalarWhereInput;
  data: RoomUpdateManyDataInput;
}

export interface PostCreateManyWithoutTagsInput {
  create?: PostCreateWithoutTagsInput[] | PostCreateWithoutTagsInput;
  connect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
}

export interface RoomUpdateManyDataInput {
  name?: String;
  roomType?: ROOM_TYPE;
  price?: Float;
  people?: Int;
}

export interface TagCreateInput {
  name: String;
  color?: String;
  posts?: PostCreateManyWithoutTagsInput;
}

export interface FavoriteUpdateManyWithoutHotelsInput {
  create?:
    | FavoriteCreateWithoutHotelsInput[]
    | FavoriteCreateWithoutHotelsInput;
  delete?: FavoriteWhereUniqueInput[] | FavoriteWhereUniqueInput;
  connect?: FavoriteWhereUniqueInput[] | FavoriteWhereUniqueInput;
  disconnect?: FavoriteWhereUniqueInput[] | FavoriteWhereUniqueInput;
  update?:
    | FavoriteUpdateWithWhereUniqueWithoutHotelsInput[]
    | FavoriteUpdateWithWhereUniqueWithoutHotelsInput;
  upsert?:
    | FavoriteUpsertWithWhereUniqueWithoutHotelsInput[]
    | FavoriteUpsertWithWhereUniqueWithoutHotelsInput;
  deleteMany?: FavoriteScalarWhereInput[] | FavoriteScalarWhereInput;
}

export interface RoomUpsertWithoutPhotosInput {
  update: RoomUpdateWithoutPhotosDataInput;
  create: RoomCreateWithoutPhotosInput;
}

export interface FavoriteUpdateWithWhereUniqueWithoutHotelsInput {
  where: FavoriteWhereUniqueInput;
  data: FavoriteUpdateWithoutHotelsDataInput;
}

export interface HotelWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  latitude?: Float;
  latitude_not?: Float;
  latitude_in?: Float[] | Float;
  latitude_not_in?: Float[] | Float;
  latitude_lt?: Float;
  latitude_lte?: Float;
  latitude_gt?: Float;
  latitude_gte?: Float;
  longitude?: Float;
  longitude_not?: Float;
  longitude_in?: Float[] | Float;
  longitude_not_in?: Float[] | Float;
  longitude_lt?: Float;
  longitude_lte?: Float;
  longitude_gt?: Float;
  longitude_gte?: Float;
  appliances?: String;
  appliances_not?: String;
  appliances_in?: String[] | String;
  appliances_not_in?: String[] | String;
  appliances_lt?: String;
  appliances_lte?: String;
  appliances_gt?: String;
  appliances_gte?: String;
  appliances_contains?: String;
  appliances_not_contains?: String;
  appliances_starts_with?: String;
  appliances_not_starts_with?: String;
  appliances_ends_with?: String;
  appliances_not_ends_with?: String;
  tel?: String;
  tel_not?: String;
  tel_in?: String[] | String;
  tel_not_in?: String[] | String;
  tel_lt?: String;
  tel_lte?: String;
  tel_gt?: String;
  tel_gte?: String;
  tel_contains?: String;
  tel_not_contains?: String;
  tel_starts_with?: String;
  tel_not_starts_with?: String;
  tel_ends_with?: String;
  tel_not_ends_with?: String;
  fax?: String;
  fax_not?: String;
  fax_in?: String[] | String;
  fax_not_in?: String[] | String;
  fax_lt?: String;
  fax_lte?: String;
  fax_gt?: String;
  fax_gte?: String;
  fax_contains?: String;
  fax_not_contains?: String;
  fax_starts_with?: String;
  fax_not_starts_with?: String;
  fax_ends_with?: String;
  fax_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  isPublished?: Boolean;
  isPublished_not?: Boolean;
  country?: CountryWhereInput;
  area?: AreaWhereInput;
  photos?: HotelPhotoWhereInput;
  rooms_every?: RoomWhereInput;
  rooms_some?: RoomWhereInput;
  rooms_none?: RoomWhereInput;
  favorites_every?: FavoriteWhereInput;
  favorites_some?: FavoriteWhereInput;
  favorites_none?: FavoriteWhereInput;
  advantages_every?: AdvantageWhereInput;
  advantages_some?: AdvantageWhereInput;
  advantages_none?: AdvantageWhereInput;
  bookings_every?: BookingWhereInput;
  bookings_some?: BookingWhereInput;
  bookings_none?: BookingWhereInput;
  reviews_every?: ReviewWhereInput;
  reviews_some?: ReviewWhereInput;
  reviews_none?: ReviewWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: HotelWhereInput[] | HotelWhereInput;
  OR?: HotelWhereInput[] | HotelWhereInput;
  NOT?: HotelWhereInput[] | HotelWhereInput;
}

export interface FavoriteUpdateWithoutHotelsDataInput {
  user?: UserUpdateOneRequiredWithoutFavoritesInput;
}

export interface RoomUpdateOneRequiredWithoutPhotosInput {
  create?: RoomCreateWithoutPhotosInput;
  update?: RoomUpdateWithoutPhotosDataInput;
  upsert?: RoomUpsertWithoutPhotosInput;
  connect?: RoomWhereUniqueInput;
}

export interface UserUpdateOneRequiredWithoutFavoritesInput {
  create?: UserCreateWithoutFavoritesInput;
  update?: UserUpdateWithoutFavoritesDataInput;
  upsert?: UserUpsertWithoutFavoritesInput;
  connect?: UserWhereUniqueInput;
}

export type PostWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  title?: String;
}>;

export interface UserUpdateWithoutFavoritesDataInput {
  email?: String;
  auth0UserId?: String;
  omiseCustomerId?: String;
  role?: ROLE;
  avatar?: UserPhotoUpdateOneWithoutUserInput;
  posts?: PostUpdateManyWithoutAuthorInput;
  profile?: ProfileUpdateOneWithoutUserInput;
  bookings?: BookingUpdateManyWithoutUserInput;
  reviews?: ReviewUpdateManyWithoutUserInput;
}

export interface RoomCreateOneWithoutPhotosInput {
  create?: RoomCreateWithoutPhotosInput;
  connect?: RoomWhereUniqueInput;
}

export interface UserPhotoUpdateOneWithoutUserInput {
  create?: UserPhotoCreateWithoutUserInput;
  update?: UserPhotoUpdateWithoutUserDataInput;
  upsert?: UserPhotoUpsertWithoutUserInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserPhotoWhereUniqueInput;
}

export type PostCategoryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface UserPhotoUpdateWithoutUserDataInput {
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  isImage?: Boolean;
  isStored?: Boolean;
  mimeType?: String;
  size?: Int;
}

export interface HotelUpsertWithoutRoomsInput {
  update: HotelUpdateWithoutRoomsDataInput;
  create: HotelCreateWithoutRoomsInput;
}

export interface UserPhotoUpsertWithoutUserInput {
  update: UserPhotoUpdateWithoutUserDataInput;
  create: UserPhotoCreateWithoutUserInput;
}

export type PostHeroWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PostUpdateManyWithoutAuthorInput {
  create?: PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput;
  delete?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  connect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  disconnect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  update?:
    | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    | PostUpdateWithWhereUniqueWithoutAuthorInput;
  upsert?:
    | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    | PostUpsertWithWhereUniqueWithoutAuthorInput;
  deleteMany?: PostScalarWhereInput[] | PostScalarWhereInput;
  updateMany?:
    | PostUpdateManyWithWhereNestedInput[]
    | PostUpdateManyWithWhereNestedInput;
}

export interface RoomUpdateInput {
  name?: String;
  roomType?: ROOM_TYPE;
  price?: Float;
  people?: Int;
  photos?: RoomPhotoUpdateManyWithoutRoomInput;
  hotel?: HotelUpdateOneRequiredWithoutRoomsInput;
}

export interface PostUpdateWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  data: PostUpdateWithoutAuthorDataInput;
}

export interface HotelCreateOneWithoutRoomsInput {
  create?: HotelCreateWithoutRoomsInput;
  connect?: HotelWhereUniqueInput;
}

export interface PostUpdateWithoutAuthorDataInput {
  title?: String;
  mdContents?: String;
  category?: PostCategoryUpdateOneWithoutPostsInput;
  tags?: TagUpdateManyWithoutPostsInput;
  hero?: PostHeroUpdateOneWithoutPostInput;
  photos?: PostPhotosUpdateOneWithoutPostInput;
}

export interface RoomCreateInput {
  name: String;
  roomType?: ROOM_TYPE;
  price?: Float;
  people?: Int;
  photos?: RoomPhotoCreateManyWithoutRoomInput;
  hotel: HotelCreateOneWithoutRoomsInput;
}

export interface PostCategoryUpdateOneWithoutPostsInput {
  create?: PostCategoryCreateWithoutPostsInput;
  update?: PostCategoryUpdateWithoutPostsDataInput;
  upsert?: PostCategoryUpsertWithoutPostsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PostCategoryWhereUniqueInput;
}

export interface ReviewUpdateInput {
  rating?: Float;
  description?: String;
  hotel?: HotelUpdateOneRequiredWithoutReviewsInput;
  user?: UserUpdateOneRequiredWithoutReviewsInput;
}

export interface PostCategoryUpdateWithoutPostsDataInput {
  name?: String;
  isRoot?: Boolean;
  children?: PostCategoryUpdateManyInput;
}

export type ProfileWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PostCategoryUpdateManyInput {
  create?: PostCategoryCreateInput[] | PostCategoryCreateInput;
  update?:
    | PostCategoryUpdateWithWhereUniqueNestedInput[]
    | PostCategoryUpdateWithWhereUniqueNestedInput;
  upsert?:
    | PostCategoryUpsertWithWhereUniqueNestedInput[]
    | PostCategoryUpsertWithWhereUniqueNestedInput;
  delete?: PostCategoryWhereUniqueInput[] | PostCategoryWhereUniqueInput;
  connect?: PostCategoryWhereUniqueInput[] | PostCategoryWhereUniqueInput;
  disconnect?: PostCategoryWhereUniqueInput[] | PostCategoryWhereUniqueInput;
  deleteMany?: PostCategoryScalarWhereInput[] | PostCategoryScalarWhereInput;
  updateMany?:
    | PostCategoryUpdateManyWithWhereNestedInput[]
    | PostCategoryUpdateManyWithWhereNestedInput;
}

export interface UserUpsertWithoutProfileInput {
  update: UserUpdateWithoutProfileDataInput;
  create: UserCreateWithoutProfileInput;
}

export interface PostCategoryUpdateWithWhereUniqueNestedInput {
  where: PostCategoryWhereUniqueInput;
  data: PostCategoryUpdateDataInput;
}

export interface UserUpdateOneRequiredWithoutProfileInput {
  create?: UserCreateWithoutProfileInput;
  update?: UserUpdateWithoutProfileDataInput;
  upsert?: UserUpsertWithoutProfileInput;
  connect?: UserWhereUniqueInput;
}

export interface PostCategoryUpdateDataInput {
  name?: String;
  isRoot?: Boolean;
  posts?: PostUpdateManyWithoutCategoryInput;
  children?: PostCategoryUpdateManyInput;
}

export interface ProfileUpdateInput {
  firstName?: String;
  lastName?: String;
  passportNo?: String;
  address?: String;
  tel?: String;
  subscriptionEmail?: String;
  user?: UserUpdateOneRequiredWithoutProfileInput;
}

export interface PostCategoryUpdateManyMutationInput {
  name?: String;
  isRoot?: Boolean;
}

export interface UserCreateOneWithoutProfileInput {
  create?: UserCreateWithoutProfileInput;
  connect?: UserWhereUniqueInput;
}

export interface PostUpdateWithWhereUniqueWithoutCategoryInput {
  where: PostWhereUniqueInput;
  data: PostUpdateWithoutCategoryDataInput;
}

export interface ProfileCreateInput {
  firstName?: String;
  lastName?: String;
  passportNo: String;
  address?: String;
  tel?: String;
  subscriptionEmail?: String;
  user: UserCreateOneWithoutProfileInput;
}

export interface PostUpdateWithoutCategoryDataInput {
  title?: String;
  mdContents?: String;
  author?: UserUpdateOneRequiredWithoutPostsInput;
  tags?: TagUpdateManyWithoutPostsInput;
  hero?: PostHeroUpdateOneWithoutPostInput;
  photos?: PostPhotosUpdateOneWithoutPostInput;
}

export interface PostUpsertWithoutPhotosInput {
  update: PostUpdateWithoutPhotosDataInput;
  create: PostCreateWithoutPhotosInput;
}

export interface UserUpdateOneRequiredWithoutPostsInput {
  create?: UserCreateWithoutPostsInput;
  update?: UserUpdateWithoutPostsDataInput;
  upsert?: UserUpsertWithoutPostsInput;
  connect?: UserWhereUniqueInput;
}

export interface PostUpdateWithoutPhotosDataInput {
  title?: String;
  mdContents?: String;
  author?: UserUpdateOneRequiredWithoutPostsInput;
  category?: PostCategoryUpdateOneWithoutPostsInput;
  tags?: TagUpdateManyWithoutPostsInput;
  hero?: PostHeroUpdateOneWithoutPostInput;
}

export interface UserUpdateWithoutPostsDataInput {
  email?: String;
  auth0UserId?: String;
  omiseCustomerId?: String;
  role?: ROLE;
  avatar?: UserPhotoUpdateOneWithoutUserInput;
  profile?: ProfileUpdateOneWithoutUserInput;
  favorites?: FavoriteUpdateManyWithoutUserInput;
  bookings?: BookingUpdateManyWithoutUserInput;
  reviews?: ReviewUpdateManyWithoutUserInput;
}

export interface PostPhotosUpdateInput {
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  count?: Int;
  isImage?: Boolean;
  isStored?: Boolean;
  size?: Int;
  post?: PostUpdateOneWithoutPhotosInput;
}

export interface ProfileUpdateOneWithoutUserInput {
  create?: ProfileCreateWithoutUserInput;
  update?: ProfileUpdateWithoutUserDataInput;
  upsert?: ProfileUpsertWithoutUserInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ProfileWhereUniqueInput;
}

export interface PostCreateWithoutPhotosInput {
  title: String;
  mdContents: String;
  author: UserCreateOneWithoutPostsInput;
  category?: PostCategoryCreateOneWithoutPostsInput;
  tags?: TagCreateManyWithoutPostsInput;
  hero?: PostHeroCreateOneWithoutPostInput;
}

export interface ProfileUpdateWithoutUserDataInput {
  firstName?: String;
  lastName?: String;
  passportNo?: String;
  address?: String;
  tel?: String;
  subscriptionEmail?: String;
}

export interface PostPhotosCreateInput {
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  count?: Int;
  isImage?: Boolean;
  isStored?: Boolean;
  size?: Int;
  post?: PostCreateOneWithoutPhotosInput;
}

export interface ProfileUpsertWithoutUserInput {
  update: ProfileUpdateWithoutUserDataInput;
  create: ProfileCreateWithoutUserInput;
}

export interface PostHeroUpdateManyMutationInput {
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  isImage?: Boolean;
  isStored?: Boolean;
  mimeType?: String;
  size?: Int;
}

export interface FavoriteUpdateManyWithoutUserInput {
  create?: FavoriteCreateWithoutUserInput[] | FavoriteCreateWithoutUserInput;
  delete?: FavoriteWhereUniqueInput[] | FavoriteWhereUniqueInput;
  connect?: FavoriteWhereUniqueInput[] | FavoriteWhereUniqueInput;
  disconnect?: FavoriteWhereUniqueInput[] | FavoriteWhereUniqueInput;
  update?:
    | FavoriteUpdateWithWhereUniqueWithoutUserInput[]
    | FavoriteUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | FavoriteUpsertWithWhereUniqueWithoutUserInput[]
    | FavoriteUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: FavoriteScalarWhereInput[] | FavoriteScalarWhereInput;
}

export interface PostUpdateWithoutHeroDataInput {
  title?: String;
  mdContents?: String;
  author?: UserUpdateOneRequiredWithoutPostsInput;
  category?: PostCategoryUpdateOneWithoutPostsInput;
  tags?: TagUpdateManyWithoutPostsInput;
  photos?: PostPhotosUpdateOneWithoutPostInput;
}

export interface FavoriteUpdateWithWhereUniqueWithoutUserInput {
  where: FavoriteWhereUniqueInput;
  data: FavoriteUpdateWithoutUserDataInput;
}

export type UserPhotoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface FavoriteUpdateWithoutUserDataInput {
  hotels?: HotelUpdateOneRequiredWithoutFavoritesInput;
}

export interface PostCreateWithoutHeroInput {
  title: String;
  mdContents: String;
  author: UserCreateOneWithoutPostsInput;
  category?: PostCategoryCreateOneWithoutPostsInput;
  tags?: TagCreateManyWithoutPostsInput;
  photos?: PostPhotosCreateOneWithoutPostInput;
}

export interface HotelUpdateOneRequiredWithoutFavoritesInput {
  create?: HotelCreateWithoutFavoritesInput;
  update?: HotelUpdateWithoutFavoritesDataInput;
  upsert?: HotelUpsertWithoutFavoritesInput;
  connect?: HotelWhereUniqueInput;
}

export interface PostHeroCreateInput {
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  isImage?: Boolean;
  isStored?: Boolean;
  mimeType?: String;
  size?: Int;
  post?: PostCreateOneWithoutHeroInput;
}

export interface HotelUpdateWithoutFavoritesDataInput {
  name?: String;
  address?: String;
  latitude?: Float;
  longitude?: Float;
  appliances?: String;
  tel?: String;
  fax?: String;
  email?: String;
  isPublished?: Boolean;
  country?: CountryUpdateOneRequiredWithoutHotelsInput;
  area?: AreaUpdateOneRequiredWithoutHotelsInput;
  photos?: HotelPhotoUpdateOneWithoutHotelInput;
  rooms?: RoomUpdateManyWithoutHotelInput;
  advantages?: AdvantageUpdateManyWithoutHotelsInput;
  bookings?: BookingUpdateManyWithoutHotelInput;
  reviews?: ReviewUpdateManyWithoutHotelInput;
}

export interface AdvantageCreateInput {
  name: String;
  iconName: String;
  icon?: AdvantageIconCreateOneWithoutAdvantageInput;
  hotels?: HotelCreateManyWithoutAdvantagesInput;
}

export interface BookingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  isPaid?: Boolean;
  isPaid_not?: Boolean;
  isConfirmed?: Boolean;
  isConfirmed_not?: Boolean;
  checkIn?: DateTimeInput;
  checkIn_not?: DateTimeInput;
  checkIn_in?: DateTimeInput[] | DateTimeInput;
  checkIn_not_in?: DateTimeInput[] | DateTimeInput;
  checkIn_lt?: DateTimeInput;
  checkIn_lte?: DateTimeInput;
  checkIn_gt?: DateTimeInput;
  checkIn_gte?: DateTimeInput;
  checkOut?: DateTimeInput;
  checkOut_not?: DateTimeInput;
  checkOut_in?: DateTimeInput[] | DateTimeInput;
  checkOut_not_in?: DateTimeInput[] | DateTimeInput;
  checkOut_lt?: DateTimeInput;
  checkOut_lte?: DateTimeInput;
  checkOut_gt?: DateTimeInput;
  checkOut_gte?: DateTimeInput;
  qty?: Int;
  qty_not?: Int;
  qty_in?: Int[] | Int;
  qty_not_in?: Int[] | Int;
  qty_lt?: Int;
  qty_lte?: Int;
  qty_gt?: Int;
  qty_gte?: Int;
  nights?: Int;
  nights_not?: Int;
  nights_in?: Int[] | Int;
  nights_not_in?: Int[] | Int;
  nights_lt?: Int;
  nights_lte?: Int;
  nights_gt?: Int;
  nights_gte?: Int;
  totalAmount?: Int;
  totalAmount_not?: Int;
  totalAmount_in?: Int[] | Int;
  totalAmount_not_in?: Int[] | Int;
  totalAmount_lt?: Int;
  totalAmount_lte?: Int;
  totalAmount_gt?: Int;
  totalAmount_gte?: Int;
  hotel?: HotelWhereInput;
  user?: UserWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: BookingWhereInput[] | BookingWhereInput;
  OR?: BookingWhereInput[] | BookingWhereInput;
  NOT?: BookingWhereInput[] | BookingWhereInput;
}

export interface AdvantageIconCreateWithoutAdvantageInput {
  name: String;
  cdnUrl: String;
  uuid: String;
  isImage: Boolean;
  isStored: Boolean;
  mimeType: String;
  size: Int;
}

export interface AdvantageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  iconName?: String;
  iconName_not?: String;
  iconName_in?: String[] | String;
  iconName_not_in?: String[] | String;
  iconName_lt?: String;
  iconName_lte?: String;
  iconName_gt?: String;
  iconName_gte?: String;
  iconName_contains?: String;
  iconName_not_contains?: String;
  iconName_starts_with?: String;
  iconName_not_starts_with?: String;
  iconName_ends_with?: String;
  iconName_not_ends_with?: String;
  icon?: AdvantageIconWhereInput;
  hotels_every?: HotelWhereInput;
  hotels_some?: HotelWhereInput;
  hotels_none?: HotelWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: AdvantageWhereInput[] | AdvantageWhereInput;
  OR?: AdvantageWhereInput[] | AdvantageWhereInput;
  NOT?: AdvantageWhereInput[] | AdvantageWhereInput;
}

export interface HotelCreateWithoutAdvantagesInput {
  name: String;
  address: String;
  latitude?: Float;
  longitude?: Float;
  appliances: String;
  tel: String;
  fax?: String;
  email: String;
  isPublished?: Boolean;
  country: CountryCreateOneWithoutHotelsInput;
  area: AreaCreateOneWithoutHotelsInput;
  photos?: HotelPhotoCreateOneWithoutHotelInput;
  rooms?: RoomCreateManyWithoutHotelInput;
  favorites?: FavoriteCreateManyWithoutHotelsInput;
  bookings?: BookingCreateManyWithoutHotelInput;
  reviews?: ReviewCreateManyWithoutHotelInput;
}

export interface PostPhotosWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  cdnUrl?: String;
  cdnUrl_not?: String;
  cdnUrl_in?: String[] | String;
  cdnUrl_not_in?: String[] | String;
  cdnUrl_lt?: String;
  cdnUrl_lte?: String;
  cdnUrl_gt?: String;
  cdnUrl_gte?: String;
  cdnUrl_contains?: String;
  cdnUrl_not_contains?: String;
  cdnUrl_starts_with?: String;
  cdnUrl_not_starts_with?: String;
  cdnUrl_ends_with?: String;
  cdnUrl_not_ends_with?: String;
  uuid?: String;
  uuid_not?: String;
  uuid_in?: String[] | String;
  uuid_not_in?: String[] | String;
  uuid_lt?: String;
  uuid_lte?: String;
  uuid_gt?: String;
  uuid_gte?: String;
  uuid_contains?: String;
  uuid_not_contains?: String;
  uuid_starts_with?: String;
  uuid_not_starts_with?: String;
  uuid_ends_with?: String;
  uuid_not_ends_with?: String;
  count?: Int;
  count_not?: Int;
  count_in?: Int[] | Int;
  count_not_in?: Int[] | Int;
  count_lt?: Int;
  count_lte?: Int;
  count_gt?: Int;
  count_gte?: Int;
  isImage?: Boolean;
  isImage_not?: Boolean;
  isStored?: Boolean;
  isStored_not?: Boolean;
  size?: Int;
  size_not?: Int;
  size_in?: Int[] | Int;
  size_not_in?: Int[] | Int;
  size_lt?: Int;
  size_lte?: Int;
  size_gt?: Int;
  size_gte?: Int;
  post?: PostWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: PostPhotosWhereInput[] | PostPhotosWhereInput;
  OR?: PostPhotosWhereInput[] | PostPhotosWhereInput;
  NOT?: PostPhotosWhereInput[] | PostPhotosWhereInput;
}

export interface CountryCreateWithoutHotelsInput {
  name: String;
  code: String;
  slug: String;
  areas?: AreaCreateManyWithoutCountryInput;
}

export interface PostCategoryUpdateInput {
  name?: String;
  isRoot?: Boolean;
  posts?: PostUpdateManyWithoutCategoryInput;
  children?: PostCategoryUpdateManyInput;
}

export interface AreaCreateWithoutCountryInput {
  name: String;
  code: String;
  slug: String;
  hotels?: HotelCreateManyWithoutAreaInput;
}

export interface HotelUpdateManyWithoutCountryInput {
  create?: HotelCreateWithoutCountryInput[] | HotelCreateWithoutCountryInput;
  delete?: HotelWhereUniqueInput[] | HotelWhereUniqueInput;
  connect?: HotelWhereUniqueInput[] | HotelWhereUniqueInput;
  disconnect?: HotelWhereUniqueInput[] | HotelWhereUniqueInput;
  update?:
    | HotelUpdateWithWhereUniqueWithoutCountryInput[]
    | HotelUpdateWithWhereUniqueWithoutCountryInput;
  upsert?:
    | HotelUpsertWithWhereUniqueWithoutCountryInput[]
    | HotelUpsertWithWhereUniqueWithoutCountryInput;
  deleteMany?: HotelScalarWhereInput[] | HotelScalarWhereInput;
  updateMany?:
    | HotelUpdateManyWithWhereNestedInput[]
    | HotelUpdateManyWithWhereNestedInput;
}

export interface HotelCreateWithoutAreaInput {
  name: String;
  address: String;
  latitude?: Float;
  longitude?: Float;
  appliances: String;
  tel: String;
  fax?: String;
  email: String;
  isPublished?: Boolean;
  country: CountryCreateOneWithoutHotelsInput;
  photos?: HotelPhotoCreateOneWithoutHotelInput;
  rooms?: RoomCreateManyWithoutHotelInput;
  favorites?: FavoriteCreateManyWithoutHotelsInput;
  advantages?: AdvantageCreateManyWithoutHotelsInput;
  bookings?: BookingCreateManyWithoutHotelInput;
  reviews?: ReviewCreateManyWithoutHotelInput;
}

export interface HotelUpdateWithWhereUniqueWithoutCountryInput {
  where: HotelWhereUniqueInput;
  data: HotelUpdateWithoutCountryDataInput;
}

export interface HotelPhotoCreateWithoutHotelInput {
  name: String;
  cdnUrl: String;
  uuid: String;
  count: Int;
  isImage: Boolean;
  isStored: Boolean;
  size: Int;
}

export interface HotelUpdateWithoutCountryDataInput {
  name?: String;
  address?: String;
  latitude?: Float;
  longitude?: Float;
  appliances?: String;
  tel?: String;
  fax?: String;
  email?: String;
  isPublished?: Boolean;
  area?: AreaUpdateOneRequiredWithoutHotelsInput;
  photos?: HotelPhotoUpdateOneWithoutHotelInput;
  rooms?: RoomUpdateManyWithoutHotelInput;
  favorites?: FavoriteUpdateManyWithoutHotelsInput;
  advantages?: AdvantageUpdateManyWithoutHotelsInput;
  bookings?: BookingUpdateManyWithoutHotelInput;
  reviews?: ReviewUpdateManyWithoutHotelInput;
}

export interface RoomCreateWithoutHotelInput {
  name: String;
  roomType?: ROOM_TYPE;
  price?: Float;
  people?: Int;
  photos?: RoomPhotoCreateManyWithoutRoomInput;
}

export interface AdvantageUpdateManyWithoutHotelsInput {
  create?:
    | AdvantageCreateWithoutHotelsInput[]
    | AdvantageCreateWithoutHotelsInput;
  delete?: AdvantageWhereUniqueInput[] | AdvantageWhereUniqueInput;
  connect?: AdvantageWhereUniqueInput[] | AdvantageWhereUniqueInput;
  disconnect?: AdvantageWhereUniqueInput[] | AdvantageWhereUniqueInput;
  update?:
    | AdvantageUpdateWithWhereUniqueWithoutHotelsInput[]
    | AdvantageUpdateWithWhereUniqueWithoutHotelsInput;
  upsert?:
    | AdvantageUpsertWithWhereUniqueWithoutHotelsInput[]
    | AdvantageUpsertWithWhereUniqueWithoutHotelsInput;
  deleteMany?: AdvantageScalarWhereInput[] | AdvantageScalarWhereInput;
  updateMany?:
    | AdvantageUpdateManyWithWhereNestedInput[]
    | AdvantageUpdateManyWithWhereNestedInput;
}

export interface RoomPhotoCreateWithoutRoomInput {
  name: String;
  cdnUrl: String;
  uuid: String;
  count: Int;
  isImage: Boolean;
  isStored: Boolean;
  size: Int;
}

export interface AdvantageUpdateWithWhereUniqueWithoutHotelsInput {
  where: AdvantageWhereUniqueInput;
  data: AdvantageUpdateWithoutHotelsDataInput;
}

export interface FavoriteCreateWithoutHotelsInput {
  user: UserCreateOneWithoutFavoritesInput;
}

export interface AdvantageUpdateWithoutHotelsDataInput {
  name?: String;
  iconName?: String;
  icon?: AdvantageIconUpdateOneWithoutAdvantageInput;
}

export interface UserCreateWithoutFavoritesInput {
  email?: String;
  auth0UserId?: String;
  omiseCustomerId?: String;
  role?: ROLE;
  avatar?: UserPhotoCreateOneWithoutUserInput;
  posts?: PostCreateManyWithoutAuthorInput;
  profile?: ProfileCreateOneWithoutUserInput;
  bookings?: BookingCreateManyWithoutUserInput;
  reviews?: ReviewCreateManyWithoutUserInput;
}

export interface AdvantageUpsertWithWhereUniqueWithoutHotelsInput {
  where: AdvantageWhereUniqueInput;
  update: AdvantageUpdateWithoutHotelsDataInput;
  create: AdvantageCreateWithoutHotelsInput;
}

export interface UserPhotoCreateWithoutUserInput {
  name: String;
  cdnUrl: String;
  uuid: String;
  isImage: Boolean;
  isStored: Boolean;
  mimeType: String;
  size: Int;
}

export interface AdvantageScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  iconName?: String;
  iconName_not?: String;
  iconName_in?: String[] | String;
  iconName_not_in?: String[] | String;
  iconName_lt?: String;
  iconName_lte?: String;
  iconName_gt?: String;
  iconName_gte?: String;
  iconName_contains?: String;
  iconName_not_contains?: String;
  iconName_starts_with?: String;
  iconName_not_starts_with?: String;
  iconName_ends_with?: String;
  iconName_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: AdvantageScalarWhereInput[] | AdvantageScalarWhereInput;
  OR?: AdvantageScalarWhereInput[] | AdvantageScalarWhereInput;
  NOT?: AdvantageScalarWhereInput[] | AdvantageScalarWhereInput;
}

export interface PostCreateWithoutAuthorInput {
  title: String;
  mdContents: String;
  category?: PostCategoryCreateOneWithoutPostsInput;
  tags?: TagCreateManyWithoutPostsInput;
  hero?: PostHeroCreateOneWithoutPostInput;
  photos?: PostPhotosCreateOneWithoutPostInput;
}

export interface AdvantageUpdateManyWithWhereNestedInput {
  where: AdvantageScalarWhereInput;
  data: AdvantageUpdateManyDataInput;
}

export interface PostCategoryCreateWithoutPostsInput {
  name: String;
  isRoot: Boolean;
  children?: PostCategoryCreateManyInput;
}

export interface AdvantageUpdateManyDataInput {
  name?: String;
  iconName?: String;
}

export interface PostCategoryCreateInput {
  name: String;
  isRoot: Boolean;
  posts?: PostCreateManyWithoutCategoryInput;
  children?: PostCategoryCreateManyInput;
}

export interface BookingUpdateManyWithoutHotelInput {
  create?: BookingCreateWithoutHotelInput[] | BookingCreateWithoutHotelInput;
  delete?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  disconnect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  update?:
    | BookingUpdateWithWhereUniqueWithoutHotelInput[]
    | BookingUpdateWithWhereUniqueWithoutHotelInput;
  upsert?:
    | BookingUpsertWithWhereUniqueWithoutHotelInput[]
    | BookingUpsertWithWhereUniqueWithoutHotelInput;
  deleteMany?: BookingScalarWhereInput[] | BookingScalarWhereInput;
  updateMany?:
    | BookingUpdateManyWithWhereNestedInput[]
    | BookingUpdateManyWithWhereNestedInput;
}

export interface PostCreateWithoutCategoryInput {
  title: String;
  mdContents: String;
  author: UserCreateOneWithoutPostsInput;
  tags?: TagCreateManyWithoutPostsInput;
  hero?: PostHeroCreateOneWithoutPostInput;
  photos?: PostPhotosCreateOneWithoutPostInput;
}

export interface BookingUpdateWithWhereUniqueWithoutHotelInput {
  where: BookingWhereUniqueInput;
  data: BookingUpdateWithoutHotelDataInput;
}

export interface UserCreateWithoutPostsInput {
  email?: String;
  auth0UserId?: String;
  omiseCustomerId?: String;
  role?: ROLE;
  avatar?: UserPhotoCreateOneWithoutUserInput;
  profile?: ProfileCreateOneWithoutUserInput;
  favorites?: FavoriteCreateManyWithoutUserInput;
  bookings?: BookingCreateManyWithoutUserInput;
  reviews?: ReviewCreateManyWithoutUserInput;
}

export interface BookingUpdateWithoutHotelDataInput {
  isPaid?: Boolean;
  isConfirmed?: Boolean;
  checkIn?: DateTimeInput;
  checkOut?: DateTimeInput;
  qty?: Int;
  nights?: Int;
  totalAmount?: Int;
  user?: UserUpdateOneRequiredWithoutBookingsInput;
}

export interface ProfileCreateWithoutUserInput {
  firstName?: String;
  lastName?: String;
  passportNo: String;
  address?: String;
  tel?: String;
  subscriptionEmail?: String;
}

export interface UserUpdateOneRequiredWithoutBookingsInput {
  create?: UserCreateWithoutBookingsInput;
  update?: UserUpdateWithoutBookingsDataInput;
  upsert?: UserUpsertWithoutBookingsInput;
  connect?: UserWhereUniqueInput;
}

export interface FavoriteCreateWithoutUserInput {
  hotels: HotelCreateOneWithoutFavoritesInput;
}

export interface UserUpdateWithoutBookingsDataInput {
  email?: String;
  auth0UserId?: String;
  omiseCustomerId?: String;
  role?: ROLE;
  avatar?: UserPhotoUpdateOneWithoutUserInput;
  posts?: PostUpdateManyWithoutAuthorInput;
  profile?: ProfileUpdateOneWithoutUserInput;
  favorites?: FavoriteUpdateManyWithoutUserInput;
  reviews?: ReviewUpdateManyWithoutUserInput;
}

export interface HotelCreateWithoutFavoritesInput {
  name: String;
  address: String;
  latitude?: Float;
  longitude?: Float;
  appliances: String;
  tel: String;
  fax?: String;
  email: String;
  isPublished?: Boolean;
  country: CountryCreateOneWithoutHotelsInput;
  area: AreaCreateOneWithoutHotelsInput;
  photos?: HotelPhotoCreateOneWithoutHotelInput;
  rooms?: RoomCreateManyWithoutHotelInput;
  advantages?: AdvantageCreateManyWithoutHotelsInput;
  bookings?: BookingCreateManyWithoutHotelInput;
  reviews?: ReviewCreateManyWithoutHotelInput;
}

export interface ReviewUpdateManyWithoutUserInput {
  create?: ReviewCreateWithoutUserInput[] | ReviewCreateWithoutUserInput;
  delete?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  disconnect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  update?:
    | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    | ReviewUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    | ReviewUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: ReviewScalarWhereInput[] | ReviewScalarWhereInput;
  updateMany?:
    | ReviewUpdateManyWithWhereNestedInput[]
    | ReviewUpdateManyWithWhereNestedInput;
}

export interface AreaCreateWithoutHotelsInput {
  name: String;
  code: String;
  slug: String;
  country: CountryCreateOneWithoutAreasInput;
}

export interface ReviewUpdateWithWhereUniqueWithoutUserInput {
  where: ReviewWhereUniqueInput;
  data: ReviewUpdateWithoutUserDataInput;
}

export interface CountryCreateWithoutAreasInput {
  name: String;
  code: String;
  slug: String;
  hotels?: HotelCreateManyWithoutCountryInput;
}

export interface ReviewUpdateWithoutUserDataInput {
  rating?: Float;
  description?: String;
  hotel?: HotelUpdateOneRequiredWithoutReviewsInput;
}

export interface HotelCreateWithoutCountryInput {
  name: String;
  address: String;
  latitude?: Float;
  longitude?: Float;
  appliances: String;
  tel: String;
  fax?: String;
  email: String;
  isPublished?: Boolean;
  area: AreaCreateOneWithoutHotelsInput;
  photos?: HotelPhotoCreateOneWithoutHotelInput;
  rooms?: RoomCreateManyWithoutHotelInput;
  favorites?: FavoriteCreateManyWithoutHotelsInput;
  advantages?: AdvantageCreateManyWithoutHotelsInput;
  bookings?: BookingCreateManyWithoutHotelInput;
  reviews?: ReviewCreateManyWithoutHotelInput;
}

export interface HotelUpdateOneRequiredWithoutReviewsInput {
  create?: HotelCreateWithoutReviewsInput;
  update?: HotelUpdateWithoutReviewsDataInput;
  upsert?: HotelUpsertWithoutReviewsInput;
  connect?: HotelWhereUniqueInput;
}

export interface AdvantageCreateWithoutHotelsInput {
  name: String;
  iconName: String;
  icon?: AdvantageIconCreateOneWithoutAdvantageInput;
}

export interface HotelUpdateWithoutReviewsDataInput {
  name?: String;
  address?: String;
  latitude?: Float;
  longitude?: Float;
  appliances?: String;
  tel?: String;
  fax?: String;
  email?: String;
  isPublished?: Boolean;
  country?: CountryUpdateOneRequiredWithoutHotelsInput;
  area?: AreaUpdateOneRequiredWithoutHotelsInput;
  photos?: HotelPhotoUpdateOneWithoutHotelInput;
  rooms?: RoomUpdateManyWithoutHotelInput;
  favorites?: FavoriteUpdateManyWithoutHotelsInput;
  advantages?: AdvantageUpdateManyWithoutHotelsInput;
  bookings?: BookingUpdateManyWithoutHotelInput;
}

export interface BookingCreateWithoutHotelInput {
  isPaid?: Boolean;
  isConfirmed?: Boolean;
  checkIn: DateTimeInput;
  checkOut: DateTimeInput;
  qty: Int;
  nights: Int;
  totalAmount: Int;
  user: UserCreateOneWithoutBookingsInput;
}

export interface HotelUpsertWithoutReviewsInput {
  update: HotelUpdateWithoutReviewsDataInput;
  create: HotelCreateWithoutReviewsInput;
}

export interface UserCreateWithoutBookingsInput {
  email?: String;
  auth0UserId?: String;
  omiseCustomerId?: String;
  role?: ROLE;
  avatar?: UserPhotoCreateOneWithoutUserInput;
  posts?: PostCreateManyWithoutAuthorInput;
  profile?: ProfileCreateOneWithoutUserInput;
  favorites?: FavoriteCreateManyWithoutUserInput;
  reviews?: ReviewCreateManyWithoutUserInput;
}

export interface ReviewUpsertWithWhereUniqueWithoutUserInput {
  where: ReviewWhereUniqueInput;
  update: ReviewUpdateWithoutUserDataInput;
  create: ReviewCreateWithoutUserInput;
}

export interface ReviewCreateWithoutUserInput {
  rating: Float;
  description: String;
  hotel: HotelCreateOneWithoutReviewsInput;
}

export interface ReviewScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  rating?: Float;
  rating_not?: Float;
  rating_in?: Float[] | Float;
  rating_not_in?: Float[] | Float;
  rating_lt?: Float;
  rating_lte?: Float;
  rating_gt?: Float;
  rating_gte?: Float;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ReviewScalarWhereInput[] | ReviewScalarWhereInput;
  OR?: ReviewScalarWhereInput[] | ReviewScalarWhereInput;
  NOT?: ReviewScalarWhereInput[] | ReviewScalarWhereInput;
}

export interface HotelCreateWithoutReviewsInput {
  name: String;
  address: String;
  latitude?: Float;
  longitude?: Float;
  appliances: String;
  tel: String;
  fax?: String;
  email: String;
  isPublished?: Boolean;
  country: CountryCreateOneWithoutHotelsInput;
  area: AreaCreateOneWithoutHotelsInput;
  photos?: HotelPhotoCreateOneWithoutHotelInput;
  rooms?: RoomCreateManyWithoutHotelInput;
  favorites?: FavoriteCreateManyWithoutHotelsInput;
  advantages?: AdvantageCreateManyWithoutHotelsInput;
  bookings?: BookingCreateManyWithoutHotelInput;
}

export interface ReviewUpdateManyWithWhereNestedInput {
  where: ReviewScalarWhereInput;
  data: ReviewUpdateManyDataInput;
}

export interface ReviewCreateWithoutHotelInput {
  rating: Float;
  description: String;
  user: UserCreateOneWithoutReviewsInput;
}

export interface ReviewUpdateManyDataInput {
  rating?: Float;
  description?: String;
}

export interface UserCreateWithoutReviewsInput {
  email?: String;
  auth0UserId?: String;
  omiseCustomerId?: String;
  role?: ROLE;
  avatar?: UserPhotoCreateOneWithoutUserInput;
  posts?: PostCreateManyWithoutAuthorInput;
  profile?: ProfileCreateOneWithoutUserInput;
  favorites?: FavoriteCreateManyWithoutUserInput;
  bookings?: BookingCreateManyWithoutUserInput;
}

export interface UserUpsertWithoutBookingsInput {
  update: UserUpdateWithoutBookingsDataInput;
  create: UserCreateWithoutBookingsInput;
}

export interface BookingCreateWithoutUserInput {
  isPaid?: Boolean;
  isConfirmed?: Boolean;
  checkIn: DateTimeInput;
  checkOut: DateTimeInput;
  qty: Int;
  nights: Int;
  totalAmount: Int;
  hotel: HotelCreateOneWithoutBookingsInput;
}

export interface BookingUpsertWithWhereUniqueWithoutHotelInput {
  where: BookingWhereUniqueInput;
  update: BookingUpdateWithoutHotelDataInput;
  create: BookingCreateWithoutHotelInput;
}

export interface HotelCreateWithoutBookingsInput {
  name: String;
  address: String;
  latitude?: Float;
  longitude?: Float;
  appliances: String;
  tel: String;
  fax?: String;
  email: String;
  isPublished?: Boolean;
  country: CountryCreateOneWithoutHotelsInput;
  area: AreaCreateOneWithoutHotelsInput;
  photos?: HotelPhotoCreateOneWithoutHotelInput;
  rooms?: RoomCreateManyWithoutHotelInput;
  favorites?: FavoriteCreateManyWithoutHotelsInput;
  advantages?: AdvantageCreateManyWithoutHotelsInput;
  reviews?: ReviewCreateManyWithoutHotelInput;
}

export interface BookingScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  isPaid?: Boolean;
  isPaid_not?: Boolean;
  isConfirmed?: Boolean;
  isConfirmed_not?: Boolean;
  checkIn?: DateTimeInput;
  checkIn_not?: DateTimeInput;
  checkIn_in?: DateTimeInput[] | DateTimeInput;
  checkIn_not_in?: DateTimeInput[] | DateTimeInput;
  checkIn_lt?: DateTimeInput;
  checkIn_lte?: DateTimeInput;
  checkIn_gt?: DateTimeInput;
  checkIn_gte?: DateTimeInput;
  checkOut?: DateTimeInput;
  checkOut_not?: DateTimeInput;
  checkOut_in?: DateTimeInput[] | DateTimeInput;
  checkOut_not_in?: DateTimeInput[] | DateTimeInput;
  checkOut_lt?: DateTimeInput;
  checkOut_lte?: DateTimeInput;
  checkOut_gt?: DateTimeInput;
  checkOut_gte?: DateTimeInput;
  qty?: Int;
  qty_not?: Int;
  qty_in?: Int[] | Int;
  qty_not_in?: Int[] | Int;
  qty_lt?: Int;
  qty_lte?: Int;
  qty_gt?: Int;
  qty_gte?: Int;
  nights?: Int;
  nights_not?: Int;
  nights_in?: Int[] | Int;
  nights_not_in?: Int[] | Int;
  nights_lt?: Int;
  nights_lte?: Int;
  nights_gt?: Int;
  nights_gte?: Int;
  totalAmount?: Int;
  totalAmount_not?: Int;
  totalAmount_in?: Int[] | Int;
  totalAmount_not_in?: Int[] | Int;
  totalAmount_lt?: Int;
  totalAmount_lte?: Int;
  totalAmount_gt?: Int;
  totalAmount_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: BookingScalarWhereInput[] | BookingScalarWhereInput;
  OR?: BookingScalarWhereInput[] | BookingScalarWhereInput;
  NOT?: BookingScalarWhereInput[] | BookingScalarWhereInput;
}

export interface TagCreateWithoutPostsInput {
  name: String;
  color?: String;
}

export interface BookingUpdateManyWithWhereNestedInput {
  where: BookingScalarWhereInput;
  data: BookingUpdateManyDataInput;
}

export interface PostHeroCreateWithoutPostInput {
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  isImage?: Boolean;
  isStored?: Boolean;
  mimeType?: String;
  size?: Int;
}

export interface BookingUpdateManyDataInput {
  isPaid?: Boolean;
  isConfirmed?: Boolean;
  checkIn?: DateTimeInput;
  checkOut?: DateTimeInput;
  qty?: Int;
  nights?: Int;
  totalAmount?: Int;
}

export interface PostPhotosCreateWithoutPostInput {
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  count?: Int;
  isImage?: Boolean;
  isStored?: Boolean;
  size?: Int;
}

export interface ReviewUpdateManyWithoutHotelInput {
  create?: ReviewCreateWithoutHotelInput[] | ReviewCreateWithoutHotelInput;
  delete?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  disconnect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  update?:
    | ReviewUpdateWithWhereUniqueWithoutHotelInput[]
    | ReviewUpdateWithWhereUniqueWithoutHotelInput;
  upsert?:
    | ReviewUpsertWithWhereUniqueWithoutHotelInput[]
    | ReviewUpsertWithWhereUniqueWithoutHotelInput;
  deleteMany?: ReviewScalarWhereInput[] | ReviewScalarWhereInput;
  updateMany?:
    | ReviewUpdateManyWithWhereNestedInput[]
    | ReviewUpdateManyWithWhereNestedInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface ReviewUpdateWithWhereUniqueWithoutHotelInput {
  where: ReviewWhereUniqueInput;
  data: ReviewUpdateWithoutHotelDataInput;
}

export interface RoomPhotoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RoomPhotoWhereInput;
  AND?: RoomPhotoSubscriptionWhereInput[] | RoomPhotoSubscriptionWhereInput;
  OR?: RoomPhotoSubscriptionWhereInput[] | RoomPhotoSubscriptionWhereInput;
  NOT?: RoomPhotoSubscriptionWhereInput[] | RoomPhotoSubscriptionWhereInput;
}

export interface ReviewUpdateWithoutHotelDataInput {
  rating?: Float;
  description?: String;
  user?: UserUpdateOneRequiredWithoutReviewsInput;
}

export interface ProfileSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProfileWhereInput;
  AND?: ProfileSubscriptionWhereInput[] | ProfileSubscriptionWhereInput;
  OR?: ProfileSubscriptionWhereInput[] | ProfileSubscriptionWhereInput;
  NOT?: ProfileSubscriptionWhereInput[] | ProfileSubscriptionWhereInput;
}

export interface UserUpdateOneRequiredWithoutReviewsInput {
  create?: UserCreateWithoutReviewsInput;
  update?: UserUpdateWithoutReviewsDataInput;
  upsert?: UserUpsertWithoutReviewsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  auth0UserId?: String;
  auth0UserId_not?: String;
  auth0UserId_in?: String[] | String;
  auth0UserId_not_in?: String[] | String;
  auth0UserId_lt?: String;
  auth0UserId_lte?: String;
  auth0UserId_gt?: String;
  auth0UserId_gte?: String;
  auth0UserId_contains?: String;
  auth0UserId_not_contains?: String;
  auth0UserId_starts_with?: String;
  auth0UserId_not_starts_with?: String;
  auth0UserId_ends_with?: String;
  auth0UserId_not_ends_with?: String;
  omiseCustomerId?: String;
  omiseCustomerId_not?: String;
  omiseCustomerId_in?: String[] | String;
  omiseCustomerId_not_in?: String[] | String;
  omiseCustomerId_lt?: String;
  omiseCustomerId_lte?: String;
  omiseCustomerId_gt?: String;
  omiseCustomerId_gte?: String;
  omiseCustomerId_contains?: String;
  omiseCustomerId_not_contains?: String;
  omiseCustomerId_starts_with?: String;
  omiseCustomerId_not_starts_with?: String;
  omiseCustomerId_ends_with?: String;
  omiseCustomerId_not_ends_with?: String;
  role?: ROLE;
  role_not?: ROLE;
  role_in?: ROLE[] | ROLE;
  role_not_in?: ROLE[] | ROLE;
  avatar?: UserPhotoWhereInput;
  posts_every?: PostWhereInput;
  posts_some?: PostWhereInput;
  posts_none?: PostWhereInput;
  profile?: ProfileWhereInput;
  favorites_every?: FavoriteWhereInput;
  favorites_some?: FavoriteWhereInput;
  favorites_none?: FavoriteWhereInput;
  bookings_every?: BookingWhereInput;
  bookings_some?: BookingWhereInput;
  bookings_none?: BookingWhereInput;
  reviews_every?: ReviewWhereInput;
  reviews_some?: ReviewWhereInput;
  reviews_none?: ReviewWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface UserUpdateWithoutReviewsDataInput {
  email?: String;
  auth0UserId?: String;
  omiseCustomerId?: String;
  role?: ROLE;
  avatar?: UserPhotoUpdateOneWithoutUserInput;
  posts?: PostUpdateManyWithoutAuthorInput;
  profile?: ProfileUpdateOneWithoutUserInput;
  favorites?: FavoriteUpdateManyWithoutUserInput;
  bookings?: BookingUpdateManyWithoutUserInput;
}

export interface HotelPhotoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HotelPhotoWhereInput;
  AND?: HotelPhotoSubscriptionWhereInput[] | HotelPhotoSubscriptionWhereInput;
  OR?: HotelPhotoSubscriptionWhereInput[] | HotelPhotoSubscriptionWhereInput;
  NOT?: HotelPhotoSubscriptionWhereInput[] | HotelPhotoSubscriptionWhereInput;
}

export interface BookingUpdateManyWithoutUserInput {
  create?: BookingCreateWithoutUserInput[] | BookingCreateWithoutUserInput;
  delete?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  disconnect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  update?:
    | BookingUpdateWithWhereUniqueWithoutUserInput[]
    | BookingUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | BookingUpsertWithWhereUniqueWithoutUserInput[]
    | BookingUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: BookingScalarWhereInput[] | BookingScalarWhereInput;
  updateMany?:
    | BookingUpdateManyWithWhereNestedInput[]
    | BookingUpdateManyWithWhereNestedInput;
}

export interface RoomWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  roomType?: ROOM_TYPE;
  roomType_not?: ROOM_TYPE;
  roomType_in?: ROOM_TYPE[] | ROOM_TYPE;
  roomType_not_in?: ROOM_TYPE[] | ROOM_TYPE;
  price?: Float;
  price_not?: Float;
  price_in?: Float[] | Float;
  price_not_in?: Float[] | Float;
  price_lt?: Float;
  price_lte?: Float;
  price_gt?: Float;
  price_gte?: Float;
  people?: Int;
  people_not?: Int;
  people_in?: Int[] | Int;
  people_not_in?: Int[] | Int;
  people_lt?: Int;
  people_lte?: Int;
  people_gt?: Int;
  people_gte?: Int;
  photos_every?: RoomPhotoWhereInput;
  photos_some?: RoomPhotoWhereInput;
  photos_none?: RoomPhotoWhereInput;
  hotel?: HotelWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: RoomWhereInput[] | RoomWhereInput;
  OR?: RoomWhereInput[] | RoomWhereInput;
  NOT?: RoomWhereInput[] | RoomWhereInput;
}

export interface BookingUpdateWithWhereUniqueWithoutUserInput {
  where: BookingWhereUniqueInput;
  data: BookingUpdateWithoutUserDataInput;
}

export interface BookingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BookingWhereInput;
  AND?: BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput;
  OR?: BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput;
  NOT?: BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput;
}

export interface BookingUpdateWithoutUserDataInput {
  isPaid?: Boolean;
  isConfirmed?: Boolean;
  checkIn?: DateTimeInput;
  checkOut?: DateTimeInput;
  qty?: Int;
  nights?: Int;
  totalAmount?: Int;
  hotel?: HotelUpdateOneRequiredWithoutBookingsInput;
}

export interface AreaWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  country?: CountryWhereInput;
  hotels_every?: HotelWhereInput;
  hotels_some?: HotelWhereInput;
  hotels_none?: HotelWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: AreaWhereInput[] | AreaWhereInput;
  OR?: AreaWhereInput[] | AreaWhereInput;
  NOT?: AreaWhereInput[] | AreaWhereInput;
}

export interface HotelUpdateOneRequiredWithoutBookingsInput {
  create?: HotelCreateWithoutBookingsInput;
  update?: HotelUpdateWithoutBookingsDataInput;
  upsert?: HotelUpsertWithoutBookingsInput;
  connect?: HotelWhereUniqueInput;
}

export type AreaWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
  code?: String;
  slug?: String;
}>;

export interface HotelUpdateWithoutBookingsDataInput {
  name?: String;
  address?: String;
  latitude?: Float;
  longitude?: Float;
  appliances?: String;
  tel?: String;
  fax?: String;
  email?: String;
  isPublished?: Boolean;
  country?: CountryUpdateOneRequiredWithoutHotelsInput;
  area?: AreaUpdateOneRequiredWithoutHotelsInput;
  photos?: HotelPhotoUpdateOneWithoutHotelInput;
  rooms?: RoomUpdateManyWithoutHotelInput;
  favorites?: FavoriteUpdateManyWithoutHotelsInput;
  advantages?: AdvantageUpdateManyWithoutHotelsInput;
  reviews?: ReviewUpdateManyWithoutHotelInput;
}

export type BookingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface HotelUpsertWithoutBookingsInput {
  update: HotelUpdateWithoutBookingsDataInput;
  create: HotelCreateWithoutBookingsInput;
}

export type ContactWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BookingUpsertWithWhereUniqueWithoutUserInput {
  where: BookingWhereUniqueInput;
  update: BookingUpdateWithoutUserDataInput;
  create: BookingCreateWithoutUserInput;
}

export interface UserUpdateInput {
  email?: String;
  auth0UserId?: String;
  omiseCustomerId?: String;
  role?: ROLE;
  avatar?: UserPhotoUpdateOneWithoutUserInput;
  posts?: PostUpdateManyWithoutAuthorInput;
  profile?: ProfileUpdateOneWithoutUserInput;
  favorites?: FavoriteUpdateManyWithoutUserInput;
  bookings?: BookingUpdateManyWithoutUserInput;
  reviews?: ReviewUpdateManyWithoutUserInput;
}

export interface UserUpsertWithoutReviewsInput {
  update: UserUpdateWithoutReviewsDataInput;
  create: UserCreateWithoutReviewsInput;
}

export interface PostUpsertWithWhereUniqueWithoutTagsInput {
  where: PostWhereUniqueInput;
  update: PostUpdateWithoutTagsDataInput;
  create: PostCreateWithoutTagsInput;
}

export interface ReviewUpsertWithWhereUniqueWithoutHotelInput {
  where: ReviewWhereUniqueInput;
  update: ReviewUpdateWithoutHotelDataInput;
  create: ReviewCreateWithoutHotelInput;
}

export type FavoriteWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface HotelUpsertWithWhereUniqueWithoutCountryInput {
  where: HotelWhereUniqueInput;
  update: HotelUpdateWithoutCountryDataInput;
  create: HotelCreateWithoutCountryInput;
}

export type HotelWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface HotelScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  latitude?: Float;
  latitude_not?: Float;
  latitude_in?: Float[] | Float;
  latitude_not_in?: Float[] | Float;
  latitude_lt?: Float;
  latitude_lte?: Float;
  latitude_gt?: Float;
  latitude_gte?: Float;
  longitude?: Float;
  longitude_not?: Float;
  longitude_in?: Float[] | Float;
  longitude_not_in?: Float[] | Float;
  longitude_lt?: Float;
  longitude_lte?: Float;
  longitude_gt?: Float;
  longitude_gte?: Float;
  appliances?: String;
  appliances_not?: String;
  appliances_in?: String[] | String;
  appliances_not_in?: String[] | String;
  appliances_lt?: String;
  appliances_lte?: String;
  appliances_gt?: String;
  appliances_gte?: String;
  appliances_contains?: String;
  appliances_not_contains?: String;
  appliances_starts_with?: String;
  appliances_not_starts_with?: String;
  appliances_ends_with?: String;
  appliances_not_ends_with?: String;
  tel?: String;
  tel_not?: String;
  tel_in?: String[] | String;
  tel_not_in?: String[] | String;
  tel_lt?: String;
  tel_lte?: String;
  tel_gt?: String;
  tel_gte?: String;
  tel_contains?: String;
  tel_not_contains?: String;
  tel_starts_with?: String;
  tel_not_starts_with?: String;
  tel_ends_with?: String;
  tel_not_ends_with?: String;
  fax?: String;
  fax_not?: String;
  fax_in?: String[] | String;
  fax_not_in?: String[] | String;
  fax_lt?: String;
  fax_lte?: String;
  fax_gt?: String;
  fax_gte?: String;
  fax_contains?: String;
  fax_not_contains?: String;
  fax_starts_with?: String;
  fax_not_starts_with?: String;
  fax_ends_with?: String;
  fax_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  isPublished?: Boolean;
  isPublished_not?: Boolean;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: HotelScalarWhereInput[] | HotelScalarWhereInput;
  OR?: HotelScalarWhereInput[] | HotelScalarWhereInput;
  NOT?: HotelScalarWhereInput[] | HotelScalarWhereInput;
}

export type HotelPhotoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface HotelUpdateManyWithWhereNestedInput {
  where: HotelScalarWhereInput;
  data: HotelUpdateManyDataInput;
}

export interface RoomPhotoUpdateInput {
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  count?: Int;
  isImage?: Boolean;
  isStored?: Boolean;
  size?: Int;
  room?: RoomUpdateOneRequiredWithoutPhotosInput;
}

export interface HotelUpdateManyDataInput {
  name?: String;
  address?: String;
  latitude?: Float;
  longitude?: Float;
  appliances?: String;
  tel?: String;
  fax?: String;
  email?: String;
  isPublished?: Boolean;
}

export interface RoomPhotoCreateInput {
  name: String;
  cdnUrl: String;
  uuid: String;
  count: Int;
  isImage: Boolean;
  isStored: Boolean;
  size: Int;
  room: RoomCreateOneWithoutPhotosInput;
}

export interface CountryUpsertWithoutAreasInput {
  update: CountryUpdateWithoutAreasDataInput;
  create: CountryCreateWithoutAreasInput;
}

export interface HotelUpdateWithoutRoomsDataInput {
  name?: String;
  address?: String;
  latitude?: Float;
  longitude?: Float;
  appliances?: String;
  tel?: String;
  fax?: String;
  email?: String;
  isPublished?: Boolean;
  country?: CountryUpdateOneRequiredWithoutHotelsInput;
  area?: AreaUpdateOneRequiredWithoutHotelsInput;
  photos?: HotelPhotoUpdateOneWithoutHotelInput;
  favorites?: FavoriteUpdateManyWithoutHotelsInput;
  advantages?: AdvantageUpdateManyWithoutHotelsInput;
  bookings?: BookingUpdateManyWithoutHotelInput;
  reviews?: ReviewUpdateManyWithoutHotelInput;
}

export interface AreaUpsertWithoutHotelsInput {
  update: AreaUpdateWithoutHotelsDataInput;
  create: AreaCreateWithoutHotelsInput;
}

export interface HotelCreateWithoutRoomsInput {
  name: String;
  address: String;
  latitude?: Float;
  longitude?: Float;
  appliances: String;
  tel: String;
  fax?: String;
  email: String;
  isPublished?: Boolean;
  country: CountryCreateOneWithoutHotelsInput;
  area: AreaCreateOneWithoutHotelsInput;
  photos?: HotelPhotoCreateOneWithoutHotelInput;
  favorites?: FavoriteCreateManyWithoutHotelsInput;
  advantages?: AdvantageCreateManyWithoutHotelsInput;
  bookings?: BookingCreateManyWithoutHotelInput;
  reviews?: ReviewCreateManyWithoutHotelInput;
}

export interface HotelUpsertWithoutFavoritesInput {
  update: HotelUpdateWithoutFavoritesDataInput;
  create: HotelCreateWithoutFavoritesInput;
}

export interface ReviewUpdateManyMutationInput {
  rating?: Float;
  description?: String;
}

export interface FavoriteUpsertWithWhereUniqueWithoutUserInput {
  where: FavoriteWhereUniqueInput;
  update: FavoriteUpdateWithoutUserDataInput;
  create: FavoriteCreateWithoutUserInput;
}

export interface ProfileUpdateManyMutationInput {
  firstName?: String;
  lastName?: String;
  passportNo?: String;
  address?: String;
  tel?: String;
  subscriptionEmail?: String;
}

export interface FavoriteScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: FavoriteScalarWhereInput[] | FavoriteScalarWhereInput;
  OR?: FavoriteScalarWhereInput[] | FavoriteScalarWhereInput;
  NOT?: FavoriteScalarWhereInput[] | FavoriteScalarWhereInput;
}

export type ReviewWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpsertWithoutPostsInput {
  update: UserUpdateWithoutPostsDataInput;
  create: UserCreateWithoutPostsInput;
}

export type RoomWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TagUpdateManyWithoutPostsInput {
  create?: TagCreateWithoutPostsInput[] | TagCreateWithoutPostsInput;
  delete?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  disconnect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  update?:
    | TagUpdateWithWhereUniqueWithoutPostsInput[]
    | TagUpdateWithWhereUniqueWithoutPostsInput;
  upsert?:
    | TagUpsertWithWhereUniqueWithoutPostsInput[]
    | TagUpsertWithWhereUniqueWithoutPostsInput;
  deleteMany?: TagScalarWhereInput[] | TagScalarWhereInput;
  updateMany?:
    | TagUpdateManyWithWhereNestedInput[]
    | TagUpdateManyWithWhereNestedInput;
}

export type RoomPhotoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TagUpdateWithWhereUniqueWithoutPostsInput {
  where: TagWhereUniqueInput;
  data: TagUpdateWithoutPostsDataInput;
}

export type TagWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface TagUpdateWithoutPostsDataInput {
  name?: String;
  color?: String;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  auth0UserId?: String;
  omiseCustomerId?: String;
}>;

export interface TagUpsertWithWhereUniqueWithoutPostsInput {
  where: TagWhereUniqueInput;
  update: TagUpdateWithoutPostsDataInput;
  create: TagCreateWithoutPostsInput;
}

export interface PostUpdateOneWithoutHeroInput {
  create?: PostCreateWithoutHeroInput;
  update?: PostUpdateWithoutHeroDataInput;
  upsert?: PostUpsertWithoutHeroInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PostWhereUniqueInput;
}

export interface TagScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  color?: String;
  color_not?: String;
  color_in?: String[] | String;
  color_not_in?: String[] | String;
  color_lt?: String;
  color_lte?: String;
  color_gt?: String;
  color_gte?: String;
  color_contains?: String;
  color_not_contains?: String;
  color_starts_with?: String;
  color_not_starts_with?: String;
  color_ends_with?: String;
  color_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: TagScalarWhereInput[] | TagScalarWhereInput;
  OR?: TagScalarWhereInput[] | TagScalarWhereInput;
  NOT?: TagScalarWhereInput[] | TagScalarWhereInput;
}

export interface PostCreateOneWithoutHeroInput {
  create?: PostCreateWithoutHeroInput;
  connect?: PostWhereUniqueInput;
}

export interface TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput;
  data: TagUpdateManyDataInput;
}

export interface AdvantageIconCreateOneWithoutAdvantageInput {
  create?: AdvantageIconCreateWithoutAdvantageInput;
  connect?: AdvantageIconWhereUniqueInput;
}

export interface TagUpdateManyDataInput {
  name?: String;
  color?: String;
}

export interface CountryCreateOneWithoutHotelsInput {
  create?: CountryCreateWithoutHotelsInput;
  connect?: CountryWhereUniqueInput;
}

export interface PostHeroUpdateOneWithoutPostInput {
  create?: PostHeroCreateWithoutPostInput;
  update?: PostHeroUpdateWithoutPostDataInput;
  upsert?: PostHeroUpsertWithoutPostInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PostHeroWhereUniqueInput;
}

export interface HotelCreateManyWithoutAreaInput {
  create?: HotelCreateWithoutAreaInput[] | HotelCreateWithoutAreaInput;
  connect?: HotelWhereUniqueInput[] | HotelWhereUniqueInput;
}

export interface PostHeroUpdateWithoutPostDataInput {
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  isImage?: Boolean;
  isStored?: Boolean;
  mimeType?: String;
  size?: Int;
}

export interface RoomCreateManyWithoutHotelInput {
  create?: RoomCreateWithoutHotelInput[] | RoomCreateWithoutHotelInput;
  connect?: RoomWhereUniqueInput[] | RoomWhereUniqueInput;
}

export interface PostHeroUpsertWithoutPostInput {
  update: PostHeroUpdateWithoutPostDataInput;
  create: PostHeroCreateWithoutPostInput;
}

export interface FavoriteCreateManyWithoutHotelsInput {
  create?:
    | FavoriteCreateWithoutHotelsInput[]
    | FavoriteCreateWithoutHotelsInput;
  connect?: FavoriteWhereUniqueInput[] | FavoriteWhereUniqueInput;
}

export interface PostPhotosUpdateOneWithoutPostInput {
  create?: PostPhotosCreateWithoutPostInput;
  update?: PostPhotosUpdateWithoutPostDataInput;
  upsert?: PostPhotosUpsertWithoutPostInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PostPhotosWhereUniqueInput;
}

export interface UserPhotoCreateOneWithoutUserInput {
  create?: UserPhotoCreateWithoutUserInput;
  connect?: UserPhotoWhereUniqueInput;
}

export interface PostPhotosUpdateWithoutPostDataInput {
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  count?: Int;
  isImage?: Boolean;
  isStored?: Boolean;
  size?: Int;
}

export interface PostCategoryCreateOneWithoutPostsInput {
  create?: PostCategoryCreateWithoutPostsInput;
  connect?: PostCategoryWhereUniqueInput;
}

export interface PostPhotosUpsertWithoutPostInput {
  update: PostPhotosUpdateWithoutPostDataInput;
  create: PostPhotosCreateWithoutPostInput;
}

export interface PostCreateManyWithoutCategoryInput {
  create?: PostCreateWithoutCategoryInput[] | PostCreateWithoutCategoryInput;
  connect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
}

export interface PostUpsertWithWhereUniqueWithoutCategoryInput {
  where: PostWhereUniqueInput;
  update: PostUpdateWithoutCategoryDataInput;
  create: PostCreateWithoutCategoryInput;
}

export interface ProfileCreateOneWithoutUserInput {
  create?: ProfileCreateWithoutUserInput;
  connect?: ProfileWhereUniqueInput;
}

export interface PostScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  mdContents?: String;
  mdContents_not?: String;
  mdContents_in?: String[] | String;
  mdContents_not_in?: String[] | String;
  mdContents_lt?: String;
  mdContents_lte?: String;
  mdContents_gt?: String;
  mdContents_gte?: String;
  mdContents_contains?: String;
  mdContents_not_contains?: String;
  mdContents_starts_with?: String;
  mdContents_not_starts_with?: String;
  mdContents_ends_with?: String;
  mdContents_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: PostScalarWhereInput[] | PostScalarWhereInput;
  OR?: PostScalarWhereInput[] | PostScalarWhereInput;
  NOT?: PostScalarWhereInput[] | PostScalarWhereInput;
}

export interface HotelCreateOneWithoutFavoritesInput {
  create?: HotelCreateWithoutFavoritesInput;
  connect?: HotelWhereUniqueInput;
}

export interface PostUpdateManyWithWhereNestedInput {
  where: PostScalarWhereInput;
  data: PostUpdateManyDataInput;
}

export interface CountryCreateOneWithoutAreasInput {
  create?: CountryCreateWithoutAreasInput;
  connect?: CountryWhereUniqueInput;
}

export interface PostUpdateManyDataInput {
  title?: String;
  mdContents?: String;
}

export interface AdvantageCreateManyWithoutHotelsInput {
  create?:
    | AdvantageCreateWithoutHotelsInput[]
    | AdvantageCreateWithoutHotelsInput;
  connect?: AdvantageWhereUniqueInput[] | AdvantageWhereUniqueInput;
}

export interface PostCategoryUpsertWithWhereUniqueNestedInput {
  where: PostCategoryWhereUniqueInput;
  update: PostCategoryUpdateDataInput;
  create: PostCategoryCreateInput;
}

export interface UserCreateOneWithoutBookingsInput {
  create?: UserCreateWithoutBookingsInput;
  connect?: UserWhereUniqueInput;
}

export interface PostCategoryScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  isRoot?: Boolean;
  isRoot_not?: Boolean;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: PostCategoryScalarWhereInput[] | PostCategoryScalarWhereInput;
  OR?: PostCategoryScalarWhereInput[] | PostCategoryScalarWhereInput;
  NOT?: PostCategoryScalarWhereInput[] | PostCategoryScalarWhereInput;
}

export interface HotelCreateOneWithoutReviewsInput {
  create?: HotelCreateWithoutReviewsInput;
  connect?: HotelWhereUniqueInput;
}

export interface PostCategoryUpdateManyWithWhereNestedInput {
  where: PostCategoryScalarWhereInput;
  data: PostCategoryUpdateManyDataInput;
}

export interface UserCreateOneWithoutReviewsInput {
  create?: UserCreateWithoutReviewsInput;
  connect?: UserWhereUniqueInput;
}

export interface PostCategoryUpdateManyDataInput {
  name?: String;
  isRoot?: Boolean;
}

export interface HotelCreateOneWithoutBookingsInput {
  create?: HotelCreateWithoutBookingsInput;
  connect?: HotelWhereUniqueInput;
}

export interface PostCategoryUpsertWithoutPostsInput {
  update: PostCategoryUpdateWithoutPostsDataInput;
  create: PostCategoryCreateWithoutPostsInput;
}

export interface PostHeroCreateOneWithoutPostInput {
  create?: PostHeroCreateWithoutPostInput;
  connect?: PostHeroWhereUniqueInput;
}

export interface PostUpsertWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  update: PostUpdateWithoutAuthorDataInput;
  create: PostCreateWithoutAuthorInput;
}

export interface PostHeroWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  cdnUrl?: String;
  cdnUrl_not?: String;
  cdnUrl_in?: String[] | String;
  cdnUrl_not_in?: String[] | String;
  cdnUrl_lt?: String;
  cdnUrl_lte?: String;
  cdnUrl_gt?: String;
  cdnUrl_gte?: String;
  cdnUrl_contains?: String;
  cdnUrl_not_contains?: String;
  cdnUrl_starts_with?: String;
  cdnUrl_not_starts_with?: String;
  cdnUrl_ends_with?: String;
  cdnUrl_not_ends_with?: String;
  uuid?: String;
  uuid_not?: String;
  uuid_in?: String[] | String;
  uuid_not_in?: String[] | String;
  uuid_lt?: String;
  uuid_lte?: String;
  uuid_gt?: String;
  uuid_gte?: String;
  uuid_contains?: String;
  uuid_not_contains?: String;
  uuid_starts_with?: String;
  uuid_not_starts_with?: String;
  uuid_ends_with?: String;
  uuid_not_ends_with?: String;
  isImage?: Boolean;
  isImage_not?: Boolean;
  isStored?: Boolean;
  isStored_not?: Boolean;
  mimeType?: String;
  mimeType_not?: String;
  mimeType_in?: String[] | String;
  mimeType_not_in?: String[] | String;
  mimeType_lt?: String;
  mimeType_lte?: String;
  mimeType_gt?: String;
  mimeType_gte?: String;
  mimeType_contains?: String;
  mimeType_not_contains?: String;
  mimeType_starts_with?: String;
  mimeType_not_starts_with?: String;
  mimeType_ends_with?: String;
  mimeType_not_ends_with?: String;
  size?: Int;
  size_not?: Int;
  size_in?: Int[] | Int;
  size_not_in?: Int[] | Int;
  size_lt?: Int;
  size_lte?: Int;
  size_gt?: Int;
  size_gte?: Int;
  post?: PostWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: PostHeroWhereInput[] | PostHeroWhereInput;
  OR?: PostHeroWhereInput[] | PostHeroWhereInput;
  NOT?: PostHeroWhereInput[] | PostHeroWhereInput;
}

export interface UserUpsertWithoutFavoritesInput {
  update: UserUpdateWithoutFavoritesDataInput;
  create: UserCreateWithoutFavoritesInput;
}

export interface RoomSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RoomWhereInput;
  AND?: RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput;
  OR?: RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput;
  NOT?: RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput;
}

export interface FavoriteUpsertWithWhereUniqueWithoutHotelsInput {
  where: FavoriteWhereUniqueInput;
  update: FavoriteUpdateWithoutHotelsDataInput;
  create: FavoriteCreateWithoutHotelsInput;
}

export interface PostCategorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PostCategoryWhereInput;
  AND?:
    | PostCategorySubscriptionWhereInput[]
    | PostCategorySubscriptionWhereInput;
  OR?:
    | PostCategorySubscriptionWhereInput[]
    | PostCategorySubscriptionWhereInput;
  NOT?:
    | PostCategorySubscriptionWhereInput[]
    | PostCategorySubscriptionWhereInput;
}

export interface HotelUpsertWithWhereUniqueWithoutAreaInput {
  where: HotelWhereUniqueInput;
  update: HotelUpdateWithoutAreaDataInput;
  create: HotelCreateWithoutAreaInput;
}

export interface HotelPhotoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  cdnUrl?: String;
  cdnUrl_not?: String;
  cdnUrl_in?: String[] | String;
  cdnUrl_not_in?: String[] | String;
  cdnUrl_lt?: String;
  cdnUrl_lte?: String;
  cdnUrl_gt?: String;
  cdnUrl_gte?: String;
  cdnUrl_contains?: String;
  cdnUrl_not_contains?: String;
  cdnUrl_starts_with?: String;
  cdnUrl_not_starts_with?: String;
  cdnUrl_ends_with?: String;
  cdnUrl_not_ends_with?: String;
  uuid?: String;
  uuid_not?: String;
  uuid_in?: String[] | String;
  uuid_not_in?: String[] | String;
  uuid_lt?: String;
  uuid_lte?: String;
  uuid_gt?: String;
  uuid_gte?: String;
  uuid_contains?: String;
  uuid_not_contains?: String;
  uuid_starts_with?: String;
  uuid_not_starts_with?: String;
  uuid_ends_with?: String;
  uuid_not_ends_with?: String;
  count?: Int;
  count_not?: Int;
  count_in?: Int[] | Int;
  count_not_in?: Int[] | Int;
  count_lt?: Int;
  count_lte?: Int;
  count_gt?: Int;
  count_gte?: Int;
  isImage?: Boolean;
  isImage_not?: Boolean;
  isStored?: Boolean;
  isStored_not?: Boolean;
  size?: Int;
  size_not?: Int;
  size_in?: Int[] | Int;
  size_not_in?: Int[] | Int;
  size_lt?: Int;
  size_lte?: Int;
  size_gt?: Int;
  size_gte?: Int;
  hotel?: HotelWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: HotelPhotoWhereInput[] | HotelPhotoWhereInput;
  OR?: HotelPhotoWhereInput[] | HotelPhotoWhereInput;
  NOT?: HotelPhotoWhereInput[] | HotelPhotoWhereInput;
}

export interface AreaUpsertWithWhereUniqueWithoutCountryInput {
  where: AreaWhereUniqueInput;
  update: AreaUpdateWithoutCountryDataInput;
  create: AreaCreateWithoutCountryInput;
}

export interface UserPhotoUpdateManyMutationInput {
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  isImage?: Boolean;
  isStored?: Boolean;
  mimeType?: String;
  size?: Int;
}

export interface AreaScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: AreaScalarWhereInput[] | AreaScalarWhereInput;
  OR?: AreaScalarWhereInput[] | AreaScalarWhereInput;
  NOT?: AreaScalarWhereInput[] | AreaScalarWhereInput;
}

export interface UserCreateOneWithoutAvatarInput {
  create?: UserCreateWithoutAvatarInput;
  connect?: UserWhereUniqueInput;
}

export interface AreaUpdateManyWithWhereNestedInput {
  where: AreaScalarWhereInput;
  data: AreaUpdateManyDataInput;
}

export interface TagUpdateManyMutationInput {
  name?: String;
  color?: String;
}

export interface AreaUpdateManyDataInput {
  name?: String;
  code?: String;
  slug?: String;
}

export interface PostCreateWithoutTagsInput {
  title: String;
  mdContents: String;
  author: UserCreateOneWithoutPostsInput;
  category?: PostCategoryCreateOneWithoutPostsInput;
  hero?: PostHeroCreateOneWithoutPostInput;
  photos?: PostPhotosCreateOneWithoutPostInput;
}

export interface CountryUpsertWithoutHotelsInput {
  update: CountryUpdateWithoutHotelsDataInput;
  create: CountryCreateWithoutHotelsInput;
}

export interface RoomUpdateWithoutPhotosDataInput {
  name?: String;
  roomType?: ROOM_TYPE;
  price?: Float;
  people?: Int;
  hotel?: HotelUpdateOneRequiredWithoutRoomsInput;
}

export interface HotelUpsertWithWhereUniqueWithoutAdvantagesInput {
  where: HotelWhereUniqueInput;
  update: HotelUpdateWithoutAdvantagesDataInput;
  create: HotelCreateWithoutAdvantagesInput;
}

export interface RoomUpdateManyMutationInput {
  name?: String;
  roomType?: ROOM_TYPE;
  price?: Float;
  people?: Int;
}

export interface AdvantageUpdateManyMutationInput {
  name?: String;
  iconName?: String;
}

export type PostPhotosWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PostUpdateManyMutationInput {
  title?: String;
  mdContents?: String;
}

export interface UserUpdateWithoutProfileDataInput {
  email?: String;
  auth0UserId?: String;
  omiseCustomerId?: String;
  role?: ROLE;
  avatar?: UserPhotoUpdateOneWithoutUserInput;
  posts?: PostUpdateManyWithoutAuthorInput;
  favorites?: FavoriteUpdateManyWithoutUserInput;
  bookings?: BookingUpdateManyWithoutUserInput;
  reviews?: ReviewUpdateManyWithoutUserInput;
}

export interface PostUpdateInput {
  title?: String;
  mdContents?: String;
  author?: UserUpdateOneRequiredWithoutPostsInput;
  category?: PostCategoryUpdateOneWithoutPostsInput;
  tags?: TagUpdateManyWithoutPostsInput;
  hero?: PostHeroUpdateOneWithoutPostInput;
  photos?: PostPhotosUpdateOneWithoutPostInput;
}

export interface PostPhotosUpdateManyMutationInput {
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  count?: Int;
  isImage?: Boolean;
  isStored?: Boolean;
  size?: Int;
}

export interface AdvantageIconCreateInput {
  name: String;
  cdnUrl: String;
  uuid: String;
  isImage: Boolean;
  isStored: Boolean;
  mimeType: String;
  size: Int;
  advantage?: AdvantageCreateOneWithoutIconInput;
}

export interface PostCreateOneWithoutPhotosInput {
  create?: PostCreateWithoutPhotosInput;
  connect?: PostWhereUniqueInput;
}

export interface AdvantageCreateOneWithoutIconInput {
  create?: AdvantageCreateWithoutIconInput;
  connect?: AdvantageWhereUniqueInput;
}

export interface PostHeroUpdateInput {
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  isImage?: Boolean;
  isStored?: Boolean;
  mimeType?: String;
  size?: Int;
  post?: PostUpdateOneWithoutHeroInput;
}

export interface AdvantageCreateWithoutIconInput {
  name: String;
  iconName: String;
  hotels?: HotelCreateManyWithoutAdvantagesInput;
}

export interface HotelCreateManyWithoutAdvantagesInput {
  create?:
    | HotelCreateWithoutAdvantagesInput[]
    | HotelCreateWithoutAdvantagesInput;
  connect?: HotelWhereUniqueInput[] | HotelWhereUniqueInput;
}

export interface AdvantageIconUpdateInput {
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  isImage?: Boolean;
  isStored?: Boolean;
  mimeType?: String;
  size?: Int;
  advantage?: AdvantageUpdateOneWithoutIconInput;
}

export interface HotelPhotoCreateOneWithoutHotelInput {
  create?: HotelPhotoCreateWithoutHotelInput;
  connect?: HotelPhotoWhereUniqueInput;
}

export interface AdvantageUpdateOneWithoutIconInput {
  create?: AdvantageCreateWithoutIconInput;
  update?: AdvantageUpdateWithoutIconDataInput;
  upsert?: AdvantageUpsertWithoutIconInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: AdvantageWhereUniqueInput;
}

export interface UserCreateOneWithoutFavoritesInput {
  create?: UserCreateWithoutFavoritesInput;
  connect?: UserWhereUniqueInput;
}

export interface AdvantageUpdateWithoutIconDataInput {
  name?: String;
  iconName?: String;
  hotels?: HotelUpdateManyWithoutAdvantagesInput;
}

export interface PostCategoryCreateManyInput {
  create?: PostCategoryCreateInput[] | PostCategoryCreateInput;
  connect?: PostCategoryWhereUniqueInput[] | PostCategoryWhereUniqueInput;
}

export interface AdvantageUpsertWithoutIconInput {
  update: AdvantageUpdateWithoutIconDataInput;
  create: AdvantageCreateWithoutIconInput;
}

export interface FavoriteCreateManyWithoutUserInput {
  create?: FavoriteCreateWithoutUserInput[] | FavoriteCreateWithoutUserInput;
  connect?: FavoriteWhereUniqueInput[] | FavoriteWhereUniqueInput;
}

export interface AdvantageIconUpdateManyMutationInput {
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  isImage?: Boolean;
  isStored?: Boolean;
  mimeType?: String;
  size?: Int;
}

export interface HotelCreateManyWithoutCountryInput {
  create?: HotelCreateWithoutCountryInput[] | HotelCreateWithoutCountryInput;
  connect?: HotelWhereUniqueInput[] | HotelWhereUniqueInput;
}

export interface AreaCreateInput {
  name: String;
  code: String;
  slug: String;
  country: CountryCreateOneWithoutAreasInput;
  hotels?: HotelCreateManyWithoutAreaInput;
}

export interface ReviewCreateManyWithoutUserInput {
  create?: ReviewCreateWithoutUserInput[] | ReviewCreateWithoutUserInput;
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
}

export interface AreaUpdateInput {
  name?: String;
  code?: String;
  slug?: String;
  country?: CountryUpdateOneRequiredWithoutAreasInput;
  hotels?: HotelUpdateManyWithoutAreaInput;
}

export interface BookingCreateManyWithoutUserInput {
  create?: BookingCreateWithoutUserInput[] | BookingCreateWithoutUserInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
}

export interface AreaUpdateManyMutationInput {
  name?: String;
  code?: String;
  slug?: String;
}

export interface PostPhotosCreateOneWithoutPostInput {
  create?: PostPhotosCreateWithoutPostInput;
  connect?: PostPhotosWhereUniqueInput;
}

export interface BookingCreateInput {
  isPaid?: Boolean;
  isConfirmed?: Boolean;
  checkIn: DateTimeInput;
  checkOut: DateTimeInput;
  qty: Int;
  nights: Int;
  totalAmount: Int;
  hotel: HotelCreateOneWithoutBookingsInput;
  user: UserCreateOneWithoutBookingsInput;
}

export interface PostPhotosSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PostPhotosWhereInput;
  AND?: PostPhotosSubscriptionWhereInput[] | PostPhotosSubscriptionWhereInput;
  OR?: PostPhotosSubscriptionWhereInput[] | PostPhotosSubscriptionWhereInput;
  NOT?: PostPhotosSubscriptionWhereInput[] | PostPhotosSubscriptionWhereInput;
}

export interface BookingUpdateInput {
  isPaid?: Boolean;
  isConfirmed?: Boolean;
  checkIn?: DateTimeInput;
  checkOut?: DateTimeInput;
  qty?: Int;
  nights?: Int;
  totalAmount?: Int;
  hotel?: HotelUpdateOneRequiredWithoutBookingsInput;
  user?: UserUpdateOneRequiredWithoutBookingsInput;
}

export interface AdvantageIconSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AdvantageIconWhereInput;
  AND?:
    | AdvantageIconSubscriptionWhereInput[]
    | AdvantageIconSubscriptionWhereInput;
  OR?:
    | AdvantageIconSubscriptionWhereInput[]
    | AdvantageIconSubscriptionWhereInput;
  NOT?:
    | AdvantageIconSubscriptionWhereInput[]
    | AdvantageIconSubscriptionWhereInput;
}

export interface BookingUpdateManyMutationInput {
  isPaid?: Boolean;
  isConfirmed?: Boolean;
  checkIn?: DateTimeInput;
  checkOut?: DateTimeInput;
  qty?: Int;
  nights?: Int;
  totalAmount?: Int;
}

export interface ContactWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  tel?: String;
  tel_not?: String;
  tel_in?: String[] | String;
  tel_not_in?: String[] | String;
  tel_lt?: String;
  tel_lte?: String;
  tel_gt?: String;
  tel_gte?: String;
  tel_contains?: String;
  tel_not_contains?: String;
  tel_starts_with?: String;
  tel_not_starts_with?: String;
  tel_ends_with?: String;
  tel_not_ends_with?: String;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  reference?: String;
  reference_not?: String;
  reference_in?: String[] | String;
  reference_not_in?: String[] | String;
  reference_lt?: String;
  reference_lte?: String;
  reference_gt?: String;
  reference_gte?: String;
  reference_contains?: String;
  reference_not_contains?: String;
  reference_starts_with?: String;
  reference_not_starts_with?: String;
  reference_ends_with?: String;
  reference_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  isReplied?: Boolean;
  isReplied_not?: Boolean;
  replyMessage?: String;
  replyMessage_not?: String;
  replyMessage_in?: String[] | String;
  replyMessage_not_in?: String[] | String;
  replyMessage_lt?: String;
  replyMessage_lte?: String;
  replyMessage_gt?: String;
  replyMessage_gte?: String;
  replyMessage_contains?: String;
  replyMessage_not_contains?: String;
  replyMessage_starts_with?: String;
  replyMessage_not_starts_with?: String;
  replyMessage_ends_with?: String;
  replyMessage_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ContactWhereInput[] | ContactWhereInput;
  OR?: ContactWhereInput[] | ContactWhereInput;
  NOT?: ContactWhereInput[] | ContactWhereInput;
}

export interface ContactCreateInput {
  name: String;
  email: String;
  tel: String;
  title: String;
  reference?: String;
  description: String;
  isReplied?: Boolean;
  replyMessage?: String;
}

export interface RoomPhotoUpdateManyMutationInput {
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  count?: Int;
  isImage?: Boolean;
  isStored?: Boolean;
  size?: Int;
}

export interface ContactUpdateInput {
  name?: String;
  email?: String;
  tel?: String;
  title?: String;
  reference?: String;
  description?: String;
  isReplied?: Boolean;
  replyMessage?: String;
}

export interface HotelUpdateOneRequiredWithoutRoomsInput {
  create?: HotelCreateWithoutRoomsInput;
  update?: HotelUpdateWithoutRoomsDataInput;
  upsert?: HotelUpsertWithoutRoomsInput;
  connect?: HotelWhereUniqueInput;
}

export interface ContactUpdateManyMutationInput {
  name?: String;
  email?: String;
  tel?: String;
  title?: String;
  reference?: String;
  description?: String;
  isReplied?: Boolean;
  replyMessage?: String;
}

export interface UserCreateWithoutProfileInput {
  email?: String;
  auth0UserId?: String;
  omiseCustomerId?: String;
  role?: ROLE;
  avatar?: UserPhotoCreateOneWithoutUserInput;
  posts?: PostCreateManyWithoutAuthorInput;
  favorites?: FavoriteCreateManyWithoutUserInput;
  bookings?: BookingCreateManyWithoutUserInput;
  reviews?: ReviewCreateManyWithoutUserInput;
}

export interface CountryCreateInput {
  name: String;
  code: String;
  slug: String;
  areas?: AreaCreateManyWithoutCountryInput;
  hotels?: HotelCreateManyWithoutCountryInput;
}

export interface PostUpsertWithoutHeroInput {
  update: PostUpdateWithoutHeroDataInput;
  create: PostCreateWithoutHeroInput;
}

export interface CountryUpdateInput {
  name?: String;
  code?: String;
  slug?: String;
  areas?: AreaUpdateManyWithoutCountryInput;
  hotels?: HotelUpdateManyWithoutCountryInput;
}

export interface AreaCreateManyWithoutCountryInput {
  create?: AreaCreateWithoutCountryInput[] | AreaCreateWithoutCountryInput;
  connect?: AreaWhereUniqueInput[] | AreaWhereUniqueInput;
}

export interface CountryUpdateManyMutationInput {
  name?: String;
  code?: String;
  slug?: String;
}

export interface PostCreateManyWithoutAuthorInput {
  create?: PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput;
  connect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
}

export interface FavoriteCreateInput {
  user: UserCreateOneWithoutFavoritesInput;
  hotels: HotelCreateOneWithoutFavoritesInput;
}

export interface AreaCreateOneWithoutHotelsInput {
  create?: AreaCreateWithoutHotelsInput;
  connect?: AreaWhereUniqueInput;
}

export interface FavoriteUpdateInput {
  user?: UserUpdateOneRequiredWithoutFavoritesInput;
  hotels?: HotelUpdateOneRequiredWithoutFavoritesInput;
}

export interface ReviewCreateManyWithoutHotelInput {
  create?: ReviewCreateWithoutHotelInput[] | ReviewCreateWithoutHotelInput;
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
}

export interface HotelCreateInput {
  name: String;
  address: String;
  latitude?: Float;
  longitude?: Float;
  appliances: String;
  tel: String;
  fax?: String;
  email: String;
  isPublished?: Boolean;
  country: CountryCreateOneWithoutHotelsInput;
  area: AreaCreateOneWithoutHotelsInput;
  photos?: HotelPhotoCreateOneWithoutHotelInput;
  rooms?: RoomCreateManyWithoutHotelInput;
  favorites?: FavoriteCreateManyWithoutHotelsInput;
  advantages?: AdvantageCreateManyWithoutHotelsInput;
  bookings?: BookingCreateManyWithoutHotelInput;
  reviews?: ReviewCreateManyWithoutHotelInput;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TagWhereInput;
  AND?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  OR?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  NOT?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
}

export interface HotelUpdateInput {
  name?: String;
  address?: String;
  latitude?: Float;
  longitude?: Float;
  appliances?: String;
  tel?: String;
  fax?: String;
  email?: String;
  isPublished?: Boolean;
  country?: CountryUpdateOneRequiredWithoutHotelsInput;
  area?: AreaUpdateOneRequiredWithoutHotelsInput;
  photos?: HotelPhotoUpdateOneWithoutHotelInput;
  rooms?: RoomUpdateManyWithoutHotelInput;
  favorites?: FavoriteUpdateManyWithoutHotelsInput;
  advantages?: AdvantageUpdateManyWithoutHotelsInput;
  bookings?: BookingUpdateManyWithoutHotelInput;
  reviews?: ReviewUpdateManyWithoutHotelInput;
}

export interface UserUpdateOneRequiredWithoutAvatarInput {
  create?: UserCreateWithoutAvatarInput;
  update?: UserUpdateWithoutAvatarDataInput;
  upsert?: UserUpsertWithoutAvatarInput;
  connect?: UserWhereUniqueInput;
}

export interface HotelUpdateManyMutationInput {
  name?: String;
  address?: String;
  latitude?: Float;
  longitude?: Float;
  appliances?: String;
  tel?: String;
  fax?: String;
  email?: String;
  isPublished?: Boolean;
}

export interface RoomCreateWithoutPhotosInput {
  name: String;
  roomType?: ROOM_TYPE;
  price?: Float;
  people?: Int;
  hotel: HotelCreateOneWithoutRoomsInput;
}

export interface HotelPhotoCreateInput {
  name: String;
  cdnUrl: String;
  uuid: String;
  count: Int;
  isImage: Boolean;
  isStored: Boolean;
  size: Int;
  hotel?: HotelCreateOneWithoutPhotosInput;
}

export interface PostUpdateOneWithoutPhotosInput {
  create?: PostCreateWithoutPhotosInput;
  update?: PostUpdateWithoutPhotosDataInput;
  upsert?: PostUpsertWithoutPhotosInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PostWhereUniqueInput;
}

export interface HotelCreateOneWithoutPhotosInput {
  create?: HotelCreateWithoutPhotosInput;
  connect?: HotelWhereUniqueInput;
}

export interface RoomPhotoCreateManyWithoutRoomInput {
  create?: RoomPhotoCreateWithoutRoomInput[] | RoomPhotoCreateWithoutRoomInput;
  connect?: RoomPhotoWhereUniqueInput[] | RoomPhotoWhereUniqueInput;
}

export interface HotelCreateWithoutPhotosInput {
  name: String;
  address: String;
  latitude?: Float;
  longitude?: Float;
  appliances: String;
  tel: String;
  fax?: String;
  email: String;
  isPublished?: Boolean;
  country: CountryCreateOneWithoutHotelsInput;
  area: AreaCreateOneWithoutHotelsInput;
  rooms?: RoomCreateManyWithoutHotelInput;
  favorites?: FavoriteCreateManyWithoutHotelsInput;
  advantages?: AdvantageCreateManyWithoutHotelsInput;
  bookings?: BookingCreateManyWithoutHotelInput;
  reviews?: ReviewCreateManyWithoutHotelInput;
}

export interface BookingCreateManyWithoutHotelInput {
  create?: BookingCreateWithoutHotelInput[] | BookingCreateWithoutHotelInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
}

export interface HotelPhotoUpdateInput {
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  count?: Int;
  isImage?: Boolean;
  isStored?: Boolean;
  size?: Int;
  hotel?: HotelUpdateOneWithoutPhotosInput;
}

export interface RoomPhotoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  cdnUrl?: String;
  cdnUrl_not?: String;
  cdnUrl_in?: String[] | String;
  cdnUrl_not_in?: String[] | String;
  cdnUrl_lt?: String;
  cdnUrl_lte?: String;
  cdnUrl_gt?: String;
  cdnUrl_gte?: String;
  cdnUrl_contains?: String;
  cdnUrl_not_contains?: String;
  cdnUrl_starts_with?: String;
  cdnUrl_not_starts_with?: String;
  cdnUrl_ends_with?: String;
  cdnUrl_not_ends_with?: String;
  uuid?: String;
  uuid_not?: String;
  uuid_in?: String[] | String;
  uuid_not_in?: String[] | String;
  uuid_lt?: String;
  uuid_lte?: String;
  uuid_gt?: String;
  uuid_gte?: String;
  uuid_contains?: String;
  uuid_not_contains?: String;
  uuid_starts_with?: String;
  uuid_not_starts_with?: String;
  uuid_ends_with?: String;
  uuid_not_ends_with?: String;
  count?: Int;
  count_not?: Int;
  count_in?: Int[] | Int;
  count_not_in?: Int[] | Int;
  count_lt?: Int;
  count_lte?: Int;
  count_gt?: Int;
  count_gte?: Int;
  isImage?: Boolean;
  isImage_not?: Boolean;
  isStored?: Boolean;
  isStored_not?: Boolean;
  size?: Int;
  size_not?: Int;
  size_in?: Int[] | Int;
  size_not_in?: Int[] | Int;
  size_lt?: Int;
  size_lte?: Int;
  size_gt?: Int;
  size_gte?: Int;
  room?: RoomWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: RoomPhotoWhereInput[] | RoomPhotoWhereInput;
  OR?: RoomPhotoWhereInput[] | RoomPhotoWhereInput;
  NOT?: RoomPhotoWhereInput[] | RoomPhotoWhereInput;
}

export interface ReviewCreateInput {
  rating: Float;
  description: String;
  hotel: HotelCreateOneWithoutReviewsInput;
  user: UserCreateOneWithoutReviewsInput;
}

export interface HotelPhotoUpdateManyMutationInput {
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  count?: Int;
  isImage?: Boolean;
  isStored?: Boolean;
  size?: Int;
}

export interface HotelUpsertWithoutPhotosInput {
  update: HotelUpdateWithoutPhotosDataInput;
  create: HotelCreateWithoutPhotosInput;
}

export interface HotelUpdateWithoutPhotosDataInput {
  name?: String;
  address?: String;
  latitude?: Float;
  longitude?: Float;
  appliances?: String;
  tel?: String;
  fax?: String;
  email?: String;
  isPublished?: Boolean;
  country?: CountryUpdateOneRequiredWithoutHotelsInput;
  area?: AreaUpdateOneRequiredWithoutHotelsInput;
  rooms?: RoomUpdateManyWithoutHotelInput;
  favorites?: FavoriteUpdateManyWithoutHotelsInput;
  advantages?: AdvantageUpdateManyWithoutHotelsInput;
  bookings?: BookingUpdateManyWithoutHotelInput;
  reviews?: ReviewUpdateManyWithoutHotelInput;
}

export interface HotelUpdateOneWithoutPhotosInput {
  create?: HotelCreateWithoutPhotosInput;
  update?: HotelUpdateWithoutPhotosDataInput;
  upsert?: HotelUpsertWithoutPhotosInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: HotelWhereUniqueInput;
}

export interface PostUpdateWithWhereUniqueWithoutTagsInput {
  where: PostWhereUniqueInput;
  data: PostUpdateWithoutTagsDataInput;
}

export interface TagCreateManyWithoutPostsInput {
  create?: TagCreateWithoutPostsInput[] | TagCreateWithoutPostsInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
}

export interface UserCreateOneWithoutPostsInput {
  create?: UserCreateWithoutPostsInput;
  connect?: UserWhereUniqueInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPhotoPreviousValues {
  id: ID_Output;
  name: String;
  cdnUrl: String;
  uuid: String;
  isImage: Boolean;
  isStored: Boolean;
  mimeType: String;
  size: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPhotoPreviousValuesPromise
  extends Promise<UserPhotoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  cdnUrl: () => Promise<String>;
  uuid: () => Promise<String>;
  isImage: () => Promise<Boolean>;
  isStored: () => Promise<Boolean>;
  mimeType: () => Promise<String>;
  size: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPhotoPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPhotoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  cdnUrl: () => Promise<AsyncIterator<String>>;
  uuid: () => Promise<AsyncIterator<String>>;
  isImage: () => Promise<AsyncIterator<Boolean>>;
  isStored: () => Promise<AsyncIterator<Boolean>>;
  mimeType: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AreaConnection {
  pageInfo: PageInfo;
  edges: AreaEdge[];
}

export interface AreaConnectionPromise
  extends Promise<AreaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AreaEdge>>() => T;
  aggregate: <T = AggregateAreaPromise>() => T;
}

export interface AreaConnectionSubscription
  extends Promise<AsyncIterator<AreaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AreaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAreaSubscription>() => T;
}

export interface Hotel {
  id: ID_Output;
  name: String;
  address: String;
  latitude?: Float;
  longitude?: Float;
  appliances: String;
  tel: String;
  fax?: String;
  email: String;
  isPublished: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface HotelPromise extends Promise<Hotel>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  latitude: () => Promise<Float>;
  longitude: () => Promise<Float>;
  appliances: () => Promise<String>;
  tel: () => Promise<String>;
  fax: () => Promise<String>;
  email: () => Promise<String>;
  isPublished: () => Promise<Boolean>;
  country: <T = CountryPromise>() => T;
  area: <T = AreaPromise>() => T;
  photos: <T = HotelPhotoPromise>() => T;
  rooms: <T = FragmentableArray<Room>>(
    args?: {
      where?: RoomWhereInput;
      orderBy?: RoomOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  favorites: <T = FragmentableArray<Favorite>>(
    args?: {
      where?: FavoriteWhereInput;
      orderBy?: FavoriteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  advantages: <T = FragmentableArray<Advantage>>(
    args?: {
      where?: AdvantageWhereInput;
      orderBy?: AdvantageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  bookings: <T = FragmentableArray<Booking>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  reviews: <T = FragmentableArray<Review>>(
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HotelSubscription
  extends Promise<AsyncIterator<Hotel>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  latitude: () => Promise<AsyncIterator<Float>>;
  longitude: () => Promise<AsyncIterator<Float>>;
  appliances: () => Promise<AsyncIterator<String>>;
  tel: () => Promise<AsyncIterator<String>>;
  fax: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  isPublished: () => Promise<AsyncIterator<Boolean>>;
  country: <T = CountrySubscription>() => T;
  area: <T = AreaSubscription>() => T;
  photos: <T = HotelPhotoSubscription>() => T;
  rooms: <T = Promise<AsyncIterator<RoomSubscription>>>(
    args?: {
      where?: RoomWhereInput;
      orderBy?: RoomOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  favorites: <T = Promise<AsyncIterator<FavoriteSubscription>>>(
    args?: {
      where?: FavoriteWhereInput;
      orderBy?: FavoriteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  advantages: <T = Promise<AsyncIterator<AdvantageSubscription>>>(
    args?: {
      where?: AdvantageWhereInput;
      orderBy?: AdvantageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  bookings: <T = Promise<AsyncIterator<BookingSubscription>>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  reviews: <T = Promise<AsyncIterator<ReviewSubscription>>>(
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateAdvantageIcon {
  count: Int;
}

export interface AggregateAdvantageIconPromise
  extends Promise<AggregateAdvantageIcon>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAdvantageIconSubscription
  extends Promise<AsyncIterator<AggregateAdvantageIcon>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Country {
  id: ID_Output;
  name: String;
  code: String;
  slug: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CountryPromise extends Promise<Country>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  slug: () => Promise<String>;
  areas: <T = FragmentableArray<Area>>(
    args?: {
      where?: AreaWhereInput;
      orderBy?: AreaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  hotels: <T = FragmentableArray<Hotel>>(
    args?: {
      where?: HotelWhereInput;
      orderBy?: HotelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CountrySubscription
  extends Promise<AsyncIterator<Country>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  areas: <T = Promise<AsyncIterator<AreaSubscription>>>(
    args?: {
      where?: AreaWhereInput;
      orderBy?: AreaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  hotels: <T = Promise<AsyncIterator<HotelSubscription>>>(
    args?: {
      where?: HotelWhereInput;
      orderBy?: HotelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AdvantageIconEdge {
  node: AdvantageIcon;
  cursor: String;
}

export interface AdvantageIconEdgePromise
  extends Promise<AdvantageIconEdge>,
    Fragmentable {
  node: <T = AdvantageIconPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AdvantageIconEdgeSubscription
  extends Promise<AsyncIterator<AdvantageIconEdge>>,
    Fragmentable {
  node: <T = AdvantageIconSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserPhoto {
  count: Int;
}

export interface AggregateUserPhotoPromise
  extends Promise<AggregateUserPhoto>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserPhotoSubscription
  extends Promise<AsyncIterator<AggregateUserPhoto>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AdvantageIconConnection {
  pageInfo: PageInfo;
  edges: AdvantageIconEdge[];
}

export interface AdvantageIconConnectionPromise
  extends Promise<AdvantageIconConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AdvantageIconEdge>>() => T;
  aggregate: <T = AggregateAdvantageIconPromise>() => T;
}

export interface AdvantageIconConnectionSubscription
  extends Promise<AsyncIterator<AdvantageIconConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AdvantageIconEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAdvantageIconSubscription>() => T;
}

export interface UserPhotoConnection {
  pageInfo: PageInfo;
  edges: UserPhotoEdge[];
}

export interface UserPhotoConnectionPromise
  extends Promise<UserPhotoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserPhotoEdge>>() => T;
  aggregate: <T = AggregateUserPhotoPromise>() => T;
}

export interface UserPhotoConnectionSubscription
  extends Promise<AsyncIterator<UserPhotoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserPhotoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserPhotoSubscription>() => T;
}

export interface HotelPhoto {
  id: ID_Output;
  name: String;
  cdnUrl: String;
  uuid: String;
  count: Int;
  isImage: Boolean;
  isStored: Boolean;
  size: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface HotelPhotoPromise extends Promise<HotelPhoto>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  cdnUrl: () => Promise<String>;
  uuid: () => Promise<String>;
  count: () => Promise<Int>;
  isImage: () => Promise<Boolean>;
  isStored: () => Promise<Boolean>;
  size: () => Promise<Int>;
  hotel: <T = HotelPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HotelPhotoSubscription
  extends Promise<AsyncIterator<HotelPhoto>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  cdnUrl: () => Promise<AsyncIterator<String>>;
  uuid: () => Promise<AsyncIterator<String>>;
  count: () => Promise<AsyncIterator<Int>>;
  isImage: () => Promise<AsyncIterator<Boolean>>;
  isStored: () => Promise<AsyncIterator<Boolean>>;
  size: () => Promise<AsyncIterator<Int>>;
  hotel: <T = HotelSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TagPreviousValues {
  id: ID_Output;
  name: String;
  color: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TagPreviousValuesPromise
  extends Promise<TagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  color: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  color: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserPhotoEdge {
  node: UserPhoto;
  cursor: String;
}

export interface UserPhotoEdgePromise
  extends Promise<UserPhotoEdge>,
    Fragmentable {
  node: <T = UserPhotoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserPhotoEdgeSubscription
  extends Promise<AsyncIterator<UserPhotoEdge>>,
    Fragmentable {
  node: <T = UserPhotoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Advantage {
  id: ID_Output;
  name: String;
  iconName: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AdvantagePromise extends Promise<Advantage>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  iconName: () => Promise<String>;
  icon: <T = AdvantageIconPromise>() => T;
  hotels: <T = FragmentableArray<Hotel>>(
    args?: {
      where?: HotelWhereInput;
      orderBy?: HotelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AdvantageSubscription
  extends Promise<AsyncIterator<Advantage>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  iconName: () => Promise<AsyncIterator<String>>;
  icon: <T = AdvantageIconSubscription>() => T;
  hotels: <T = Promise<AsyncIterator<HotelSubscription>>>(
    args?: {
      where?: HotelWhereInput;
      orderBy?: HotelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AdvantageIcon {
  id: ID_Output;
  name: String;
  cdnUrl: String;
  uuid: String;
  isImage: Boolean;
  isStored: Boolean;
  mimeType: String;
  size: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AdvantageIconPromise
  extends Promise<AdvantageIcon>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  cdnUrl: () => Promise<String>;
  uuid: () => Promise<String>;
  isImage: () => Promise<Boolean>;
  isStored: () => Promise<Boolean>;
  mimeType: () => Promise<String>;
  size: () => Promise<Int>;
  advantage: <T = AdvantagePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AdvantageIconSubscription
  extends Promise<AsyncIterator<AdvantageIcon>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  cdnUrl: () => Promise<AsyncIterator<String>>;
  uuid: () => Promise<AsyncIterator<String>>;
  isImage: () => Promise<AsyncIterator<Boolean>>;
  isStored: () => Promise<AsyncIterator<Boolean>>;
  mimeType: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Int>>;
  advantage: <T = AdvantageSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TagEdge {
  node: Tag;
  cursor: String;
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
  node: <T = TagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdge>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AdvantageSubscriptionPayload {
  mutation: MutationType;
  node: Advantage;
  updatedFields: String[];
  previousValues: AdvantagePreviousValues;
}

export interface AdvantageSubscriptionPayloadPromise
  extends Promise<AdvantageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AdvantagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AdvantagePreviousValuesPromise>() => T;
}

export interface AdvantageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AdvantageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AdvantageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AdvantagePreviousValuesSubscription>() => T;
}

export interface AggregateRoomPhoto {
  count: Int;
}

export interface AggregateRoomPhotoPromise
  extends Promise<AggregateRoomPhoto>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRoomPhotoSubscription
  extends Promise<AsyncIterator<AggregateRoomPhoto>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AdvantagePreviousValues {
  id: ID_Output;
  name: String;
  iconName: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AdvantagePreviousValuesPromise
  extends Promise<AdvantagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  iconName: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AdvantagePreviousValuesSubscription
  extends Promise<AsyncIterator<AdvantagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  iconName: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RoomPhotoConnection {
  pageInfo: PageInfo;
  edges: RoomPhotoEdge[];
}

export interface RoomPhotoConnectionPromise
  extends Promise<RoomPhotoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RoomPhotoEdge>>() => T;
  aggregate: <T = AggregateRoomPhotoPromise>() => T;
}

export interface RoomPhotoConnectionSubscription
  extends Promise<AsyncIterator<RoomPhotoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RoomPhotoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRoomPhotoSubscription>() => T;
}

export interface AggregateAdvantage {
  count: Int;
}

export interface AggregateAdvantagePromise
  extends Promise<AggregateAdvantage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAdvantageSubscription
  extends Promise<AsyncIterator<AggregateAdvantage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RoomEdge {
  node: Room;
  cursor: String;
}

export interface RoomEdgePromise extends Promise<RoomEdge>, Fragmentable {
  node: <T = RoomPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RoomEdgeSubscription
  extends Promise<AsyncIterator<RoomEdge>>,
    Fragmentable {
  node: <T = RoomSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AdvantageIconSubscriptionPayload {
  mutation: MutationType;
  node: AdvantageIcon;
  updatedFields: String[];
  previousValues: AdvantageIconPreviousValues;
}

export interface AdvantageIconSubscriptionPayloadPromise
  extends Promise<AdvantageIconSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AdvantageIconPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AdvantageIconPreviousValuesPromise>() => T;
}

export interface AdvantageIconSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AdvantageIconSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AdvantageIconSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AdvantageIconPreviousValuesSubscription>() => T;
}

export interface AggregateReview {
  count: Int;
}

export interface AggregateReviewPromise
  extends Promise<AggregateReview>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReviewSubscription
  extends Promise<AsyncIterator<AggregateReview>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AdvantageIconPreviousValues {
  id: ID_Output;
  name: String;
  cdnUrl: String;
  uuid: String;
  isImage: Boolean;
  isStored: Boolean;
  mimeType: String;
  size: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AdvantageIconPreviousValuesPromise
  extends Promise<AdvantageIconPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  cdnUrl: () => Promise<String>;
  uuid: () => Promise<String>;
  isImage: () => Promise<Boolean>;
  isStored: () => Promise<Boolean>;
  mimeType: () => Promise<String>;
  size: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AdvantageIconPreviousValuesSubscription
  extends Promise<AsyncIterator<AdvantageIconPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  cdnUrl: () => Promise<AsyncIterator<String>>;
  uuid: () => Promise<AsyncIterator<String>>;
  isImage: () => Promise<AsyncIterator<Boolean>>;
  isStored: () => Promise<AsyncIterator<Boolean>>;
  mimeType: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReviewConnection {
  pageInfo: PageInfo;
  edges: ReviewEdge[];
}

export interface ReviewConnectionPromise
  extends Promise<ReviewConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReviewEdge>>() => T;
  aggregate: <T = AggregateReviewPromise>() => T;
}

export interface ReviewConnectionSubscription
  extends Promise<AsyncIterator<ReviewConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReviewEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReviewSubscription>() => T;
}

export interface AdvantageEdge {
  node: Advantage;
  cursor: String;
}

export interface AdvantageEdgePromise
  extends Promise<AdvantageEdge>,
    Fragmentable {
  node: <T = AdvantagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AdvantageEdgeSubscription
  extends Promise<AsyncIterator<AdvantageEdge>>,
    Fragmentable {
  node: <T = AdvantageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProfileEdge {
  node: Profile;
  cursor: String;
}

export interface ProfileEdgePromise extends Promise<ProfileEdge>, Fragmentable {
  node: <T = ProfilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProfileEdgeSubscription
  extends Promise<AsyncIterator<ProfileEdge>>,
    Fragmentable {
  node: <T = ProfileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AreaSubscriptionPayload {
  mutation: MutationType;
  node: Area;
  updatedFields: String[];
  previousValues: AreaPreviousValues;
}

export interface AreaSubscriptionPayloadPromise
  extends Promise<AreaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AreaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AreaPreviousValuesPromise>() => T;
}

export interface AreaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AreaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AreaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AreaPreviousValuesSubscription>() => T;
}

export interface UserPhotoSubscriptionPayload {
  mutation: MutationType;
  node: UserPhoto;
  updatedFields: String[];
  previousValues: UserPhotoPreviousValues;
}

export interface UserPhotoSubscriptionPayloadPromise
  extends Promise<UserPhotoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPhotoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPhotoPreviousValuesPromise>() => T;
}

export interface UserPhotoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserPhotoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserPhotoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPhotoPreviousValuesSubscription>() => T;
}

export interface AreaPreviousValues {
  id: ID_Output;
  name: String;
  code: String;
  slug: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AreaPreviousValuesPromise
  extends Promise<AreaPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  slug: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AreaPreviousValuesSubscription
  extends Promise<AsyncIterator<AreaPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PostPhotosEdge {
  node: PostPhotos;
  cursor: String;
}

export interface PostPhotosEdgePromise
  extends Promise<PostPhotosEdge>,
    Fragmentable {
  node: <T = PostPhotosPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostPhotosEdgeSubscription
  extends Promise<AsyncIterator<PostPhotosEdge>>,
    Fragmentable {
  node: <T = PostPhotosSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface Area {
  id: ID_Output;
  name: String;
  code: String;
  slug: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AreaPromise extends Promise<Area>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  slug: () => Promise<String>;
  country: <T = CountryPromise>() => T;
  hotels: <T = FragmentableArray<Hotel>>(
    args?: {
      where?: HotelWhereInput;
      orderBy?: HotelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AreaSubscription
  extends Promise<AsyncIterator<Area>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  country: <T = CountrySubscription>() => T;
  hotels: <T = Promise<AsyncIterator<HotelSubscription>>>(
    args?: {
      where?: HotelWhereInput;
      orderBy?: HotelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BookingSubscriptionPayload {
  mutation: MutationType;
  node: Booking;
  updatedFields: String[];
  previousValues: BookingPreviousValues;
}

export interface BookingSubscriptionPayloadPromise
  extends Promise<BookingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookingPreviousValuesPromise>() => T;
}

export interface BookingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookingPreviousValuesSubscription>() => T;
}

export interface PostHeroEdge {
  node: PostHero;
  cursor: String;
}

export interface PostHeroEdgePromise
  extends Promise<PostHeroEdge>,
    Fragmentable {
  node: <T = PostHeroPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostHeroEdgeSubscription
  extends Promise<AsyncIterator<PostHeroEdge>>,
    Fragmentable {
  node: <T = PostHeroSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BookingPreviousValues {
  id: ID_Output;
  isPaid: Boolean;
  isConfirmed: Boolean;
  checkIn: DateTimeOutput;
  checkOut: DateTimeOutput;
  qty: Int;
  nights: Int;
  totalAmount: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BookingPreviousValuesPromise
  extends Promise<BookingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isPaid: () => Promise<Boolean>;
  isConfirmed: () => Promise<Boolean>;
  checkIn: () => Promise<DateTimeOutput>;
  checkOut: () => Promise<DateTimeOutput>;
  qty: () => Promise<Int>;
  nights: () => Promise<Int>;
  totalAmount: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BookingPreviousValuesSubscription
  extends Promise<AsyncIterator<BookingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isPaid: () => Promise<AsyncIterator<Boolean>>;
  isConfirmed: () => Promise<AsyncIterator<Boolean>>;
  checkIn: () => Promise<AsyncIterator<DateTimeOutput>>;
  checkOut: () => Promise<AsyncIterator<DateTimeOutput>>;
  qty: () => Promise<AsyncIterator<Int>>;
  nights: () => Promise<AsyncIterator<Int>>;
  totalAmount: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserPreviousValues {
  id: ID_Output;
  email?: String;
  auth0UserId?: String;
  omiseCustomerId?: String;
  role?: ROLE;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  auth0UserId: () => Promise<String>;
  omiseCustomerId: () => Promise<String>;
  role: () => Promise<ROLE>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  auth0UserId: () => Promise<AsyncIterator<String>>;
  omiseCustomerId: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<ROLE>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AdvantageConnection {
  pageInfo: PageInfo;
  edges: AdvantageEdge[];
}

export interface AdvantageConnectionPromise
  extends Promise<AdvantageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AdvantageEdge>>() => T;
  aggregate: <T = AggregateAdvantagePromise>() => T;
}

export interface AdvantageConnectionSubscription
  extends Promise<AsyncIterator<AdvantageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AdvantageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAdvantageSubscription>() => T;
}

export interface PostCategoryEdge {
  node: PostCategory;
  cursor: String;
}

export interface PostCategoryEdgePromise
  extends Promise<PostCategoryEdge>,
    Fragmentable {
  node: <T = PostCategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostCategoryEdgeSubscription
  extends Promise<AsyncIterator<PostCategoryEdge>>,
    Fragmentable {
  node: <T = PostCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ContactSubscriptionPayload {
  mutation: MutationType;
  node: Contact;
  updatedFields: String[];
  previousValues: ContactPreviousValues;
}

export interface ContactSubscriptionPayloadPromise
  extends Promise<ContactSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContactPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContactPreviousValuesPromise>() => T;
}

export interface ContactSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContactSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContactSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContactPreviousValuesSubscription>() => T;
}

export interface AggregatePost {
  count: Int;
}

export interface AggregatePostPromise
  extends Promise<AggregatePost>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostSubscription
  extends Promise<AsyncIterator<AggregatePost>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ContactPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  tel: String;
  title: String;
  reference?: String;
  description: String;
  isReplied: Boolean;
  replyMessage?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ContactPreviousValuesPromise
  extends Promise<ContactPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  tel: () => Promise<String>;
  title: () => Promise<String>;
  reference: () => Promise<String>;
  description: () => Promise<String>;
  isReplied: () => Promise<Boolean>;
  replyMessage: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ContactPreviousValuesSubscription
  extends Promise<AsyncIterator<ContactPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  tel: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  reference: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  isReplied: () => Promise<AsyncIterator<Boolean>>;
  replyMessage: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PostConnection {
  pageInfo: PageInfo;
  edges: PostEdge[];
}

export interface PostConnectionPromise
  extends Promise<PostConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostEdge>>() => T;
  aggregate: <T = AggregatePostPromise>() => T;
}

export interface PostConnectionSubscription
  extends Promise<AsyncIterator<PostConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostSubscription>() => T;
}

export interface Review {
  id: ID_Output;
  rating: Float;
  description: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ReviewPromise extends Promise<Review>, Fragmentable {
  id: () => Promise<ID_Output>;
  rating: () => Promise<Float>;
  description: () => Promise<String>;
  hotel: <T = HotelPromise>() => T;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReviewSubscription
  extends Promise<AsyncIterator<Review>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  rating: () => Promise<AsyncIterator<Float>>;
  description: () => Promise<AsyncIterator<String>>;
  hotel: <T = HotelSubscription>() => T;
  user: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HotelPhotoEdge {
  node: HotelPhoto;
  cursor: String;
}

export interface HotelPhotoEdgePromise
  extends Promise<HotelPhotoEdge>,
    Fragmentable {
  node: <T = HotelPhotoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HotelPhotoEdgeSubscription
  extends Promise<AsyncIterator<HotelPhotoEdge>>,
    Fragmentable {
  node: <T = HotelPhotoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CountrySubscriptionPayload {
  mutation: MutationType;
  node: Country;
  updatedFields: String[];
  previousValues: CountryPreviousValues;
}

export interface CountrySubscriptionPayloadPromise
  extends Promise<CountrySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CountryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CountryPreviousValuesPromise>() => T;
}

export interface CountrySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CountrySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CountrySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CountryPreviousValuesSubscription>() => T;
}

export interface AggregateHotel {
  count: Int;
}

export interface AggregateHotelPromise
  extends Promise<AggregateHotel>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHotelSubscription
  extends Promise<AsyncIterator<AggregateHotel>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CountryPreviousValues {
  id: ID_Output;
  name: String;
  code: String;
  slug: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CountryPreviousValuesPromise
  extends Promise<CountryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  slug: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CountryPreviousValuesSubscription
  extends Promise<AsyncIterator<CountryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HotelConnection {
  pageInfo: PageInfo;
  edges: HotelEdge[];
}

export interface HotelConnectionPromise
  extends Promise<HotelConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HotelEdge>>() => T;
  aggregate: <T = AggregateHotelPromise>() => T;
}

export interface HotelConnectionSubscription
  extends Promise<AsyncIterator<HotelConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HotelEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHotelSubscription>() => T;
}

export interface Booking {
  id: ID_Output;
  isPaid: Boolean;
  isConfirmed: Boolean;
  checkIn: DateTimeOutput;
  checkOut: DateTimeOutput;
  qty: Int;
  nights: Int;
  totalAmount: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BookingPromise extends Promise<Booking>, Fragmentable {
  id: () => Promise<ID_Output>;
  isPaid: () => Promise<Boolean>;
  isConfirmed: () => Promise<Boolean>;
  checkIn: () => Promise<DateTimeOutput>;
  checkOut: () => Promise<DateTimeOutput>;
  qty: () => Promise<Int>;
  nights: () => Promise<Int>;
  totalAmount: () => Promise<Int>;
  hotel: <T = HotelPromise>() => T;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BookingSubscription
  extends Promise<AsyncIterator<Booking>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isPaid: () => Promise<AsyncIterator<Boolean>>;
  isConfirmed: () => Promise<AsyncIterator<Boolean>>;
  checkIn: () => Promise<AsyncIterator<DateTimeOutput>>;
  checkOut: () => Promise<AsyncIterator<DateTimeOutput>>;
  qty: () => Promise<AsyncIterator<Int>>;
  nights: () => Promise<AsyncIterator<Int>>;
  totalAmount: () => Promise<AsyncIterator<Int>>;
  hotel: <T = HotelSubscription>() => T;
  user: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FavoriteEdge {
  node: Favorite;
  cursor: String;
}

export interface FavoriteEdgePromise
  extends Promise<FavoriteEdge>,
    Fragmentable {
  node: <T = FavoritePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FavoriteEdgeSubscription
  extends Promise<AsyncIterator<FavoriteEdge>>,
    Fragmentable {
  node: <T = FavoriteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FavoriteSubscriptionPayload {
  mutation: MutationType;
  node: Favorite;
  updatedFields: String[];
  previousValues: FavoritePreviousValues;
}

export interface FavoriteSubscriptionPayloadPromise
  extends Promise<FavoriteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FavoritePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FavoritePreviousValuesPromise>() => T;
}

export interface FavoriteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FavoriteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FavoriteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FavoritePreviousValuesSubscription>() => T;
}

export interface AggregateCountry {
  count: Int;
}

export interface AggregateCountryPromise
  extends Promise<AggregateCountry>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCountrySubscription
  extends Promise<AsyncIterator<AggregateCountry>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FavoritePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FavoritePreviousValuesPromise
  extends Promise<FavoritePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FavoritePreviousValuesSubscription
  extends Promise<AsyncIterator<FavoritePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CountryConnection {
  pageInfo: PageInfo;
  edges: CountryEdge[];
}

export interface CountryConnectionPromise
  extends Promise<CountryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CountryEdge>>() => T;
  aggregate: <T = AggregateCountryPromise>() => T;
}

export interface CountryConnectionSubscription
  extends Promise<AsyncIterator<CountryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CountryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCountrySubscription>() => T;
}

export interface Profile {
  id: ID_Output;
  firstName?: String;
  lastName?: String;
  passportNo: String;
  address?: String;
  tel?: String;
  subscriptionEmail?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProfilePromise extends Promise<Profile>, Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  passportNo: () => Promise<String>;
  address: () => Promise<String>;
  tel: () => Promise<String>;
  subscriptionEmail: () => Promise<String>;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProfileSubscription
  extends Promise<AsyncIterator<Profile>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  passportNo: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  tel: () => Promise<AsyncIterator<String>>;
  subscriptionEmail: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateContact {
  count: Int;
}

export interface AggregateContactPromise
  extends Promise<AggregateContact>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContactSubscription
  extends Promise<AsyncIterator<AggregateContact>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HotelSubscriptionPayload {
  mutation: MutationType;
  node: Hotel;
  updatedFields: String[];
  previousValues: HotelPreviousValues;
}

export interface HotelSubscriptionPayloadPromise
  extends Promise<HotelSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HotelPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HotelPreviousValuesPromise>() => T;
}

export interface HotelSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HotelSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HotelSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HotelPreviousValuesSubscription>() => T;
}

export interface ContactConnection {
  pageInfo: PageInfo;
  edges: ContactEdge[];
}

export interface ContactConnectionPromise
  extends Promise<ContactConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContactEdge>>() => T;
  aggregate: <T = AggregateContactPromise>() => T;
}

export interface ContactConnectionSubscription
  extends Promise<AsyncIterator<ContactConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContactEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContactSubscription>() => T;
}

export interface HotelPreviousValues {
  id: ID_Output;
  name: String;
  address: String;
  latitude?: Float;
  longitude?: Float;
  appliances: String;
  tel: String;
  fax?: String;
  email: String;
  isPublished: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface HotelPreviousValuesPromise
  extends Promise<HotelPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  latitude: () => Promise<Float>;
  longitude: () => Promise<Float>;
  appliances: () => Promise<String>;
  tel: () => Promise<String>;
  fax: () => Promise<String>;
  email: () => Promise<String>;
  isPublished: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HotelPreviousValuesSubscription
  extends Promise<AsyncIterator<HotelPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  latitude: () => Promise<AsyncIterator<Float>>;
  longitude: () => Promise<AsyncIterator<Float>>;
  appliances: () => Promise<AsyncIterator<String>>;
  tel: () => Promise<AsyncIterator<String>>;
  fax: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  isPublished: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateBooking {
  count: Int;
}

export interface AggregateBookingPromise
  extends Promise<AggregateBooking>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookingSubscription
  extends Promise<AsyncIterator<AggregateBooking>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PostPhotos {
  id: ID_Output;
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  count?: Int;
  isImage?: Boolean;
  isStored?: Boolean;
  size?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PostPhotosPromise extends Promise<PostPhotos>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  cdnUrl: () => Promise<String>;
  uuid: () => Promise<String>;
  count: () => Promise<Int>;
  isImage: () => Promise<Boolean>;
  isStored: () => Promise<Boolean>;
  size: () => Promise<Int>;
  post: <T = PostPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PostPhotosSubscription
  extends Promise<AsyncIterator<PostPhotos>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  cdnUrl: () => Promise<AsyncIterator<String>>;
  uuid: () => Promise<AsyncIterator<String>>;
  count: () => Promise<AsyncIterator<Int>>;
  isImage: () => Promise<AsyncIterator<Boolean>>;
  isStored: () => Promise<AsyncIterator<Boolean>>;
  size: () => Promise<AsyncIterator<Int>>;
  post: <T = PostSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BookingConnection {
  pageInfo: PageInfo;
  edges: BookingEdge[];
}

export interface BookingConnectionPromise
  extends Promise<BookingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookingEdge>>() => T;
  aggregate: <T = AggregateBookingPromise>() => T;
}

export interface BookingConnectionSubscription
  extends Promise<AsyncIterator<BookingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BookingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBookingSubscription>() => T;
}

export interface HotelPhotoSubscriptionPayload {
  mutation: MutationType;
  node: HotelPhoto;
  updatedFields: String[];
  previousValues: HotelPhotoPreviousValues;
}

export interface HotelPhotoSubscriptionPayloadPromise
  extends Promise<HotelPhotoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HotelPhotoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HotelPhotoPreviousValuesPromise>() => T;
}

export interface HotelPhotoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HotelPhotoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HotelPhotoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HotelPhotoPreviousValuesSubscription>() => T;
}

export interface AreaEdge {
  node: Area;
  cursor: String;
}

export interface AreaEdgePromise extends Promise<AreaEdge>, Fragmentable {
  node: <T = AreaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AreaEdgeSubscription
  extends Promise<AsyncIterator<AreaEdge>>,
    Fragmentable {
  node: <T = AreaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HotelPhotoPreviousValues {
  id: ID_Output;
  name: String;
  cdnUrl: String;
  uuid: String;
  count: Int;
  isImage: Boolean;
  isStored: Boolean;
  size: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface HotelPhotoPreviousValuesPromise
  extends Promise<HotelPhotoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  cdnUrl: () => Promise<String>;
  uuid: () => Promise<String>;
  count: () => Promise<Int>;
  isImage: () => Promise<Boolean>;
  isStored: () => Promise<Boolean>;
  size: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HotelPhotoPreviousValuesSubscription
  extends Promise<AsyncIterator<HotelPhotoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  cdnUrl: () => Promise<AsyncIterator<String>>;
  uuid: () => Promise<AsyncIterator<String>>;
  count: () => Promise<AsyncIterator<Int>>;
  isImage: () => Promise<AsyncIterator<Boolean>>;
  isStored: () => Promise<AsyncIterator<Boolean>>;
  size: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface PostHero {
  id: ID_Output;
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  isImage?: Boolean;
  isStored?: Boolean;
  mimeType?: String;
  size?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PostHeroPromise extends Promise<PostHero>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  cdnUrl: () => Promise<String>;
  uuid: () => Promise<String>;
  isImage: () => Promise<Boolean>;
  isStored: () => Promise<Boolean>;
  mimeType: () => Promise<String>;
  size: () => Promise<Int>;
  post: <T = PostPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PostHeroSubscription
  extends Promise<AsyncIterator<PostHero>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  cdnUrl: () => Promise<AsyncIterator<String>>;
  uuid: () => Promise<AsyncIterator<String>>;
  isImage: () => Promise<AsyncIterator<Boolean>>;
  isStored: () => Promise<AsyncIterator<Boolean>>;
  mimeType: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Int>>;
  post: <T = PostSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TagConnection {
  pageInfo: PageInfo;
  edges: TagEdge[];
}

export interface TagConnectionPromise
  extends Promise<TagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TagEdge>>() => T;
  aggregate: <T = AggregateTagPromise>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface PostSubscriptionPayload {
  mutation: MutationType;
  node: Post;
  updatedFields: String[];
  previousValues: PostPreviousValues;
}

export interface PostSubscriptionPayloadPromise
  extends Promise<PostSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostPreviousValuesPromise>() => T;
}

export interface PostSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostPreviousValuesSubscription>() => T;
}

export interface AggregateRoom {
  count: Int;
}

export interface AggregateRoomPromise
  extends Promise<AggregateRoom>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRoomSubscription
  extends Promise<AsyncIterator<AggregateRoom>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PostPreviousValues {
  id: ID_Output;
  title: String;
  mdContents: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PostPreviousValuesPromise
  extends Promise<PostPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  mdContents: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PostPreviousValuesSubscription
  extends Promise<AsyncIterator<PostPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  mdContents: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReviewEdge {
  node: Review;
  cursor: String;
}

export interface ReviewEdgePromise extends Promise<ReviewEdge>, Fragmentable {
  node: <T = ReviewPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReviewEdgeSubscription
  extends Promise<AsyncIterator<ReviewEdge>>,
    Fragmentable {
  node: <T = ReviewSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Tag {
  id: ID_Output;
  name: String;
  color: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  color: () => Promise<String>;
  posts: <T = FragmentableArray<Post>>(
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TagSubscription
  extends Promise<AsyncIterator<Tag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  color: () => Promise<AsyncIterator<String>>;
  posts: <T = Promise<AsyncIterator<PostSubscription>>>(
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProfileConnection {
  pageInfo: PageInfo;
  edges: ProfileEdge[];
}

export interface ProfileConnectionPromise
  extends Promise<ProfileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProfileEdge>>() => T;
  aggregate: <T = AggregateProfilePromise>() => T;
}

export interface ProfileConnectionSubscription
  extends Promise<AsyncIterator<ProfileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProfileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProfileSubscription>() => T;
}

export interface PostCategorySubscriptionPayload {
  mutation: MutationType;
  node: PostCategory;
  updatedFields: String[];
  previousValues: PostCategoryPreviousValues;
}

export interface PostCategorySubscriptionPayloadPromise
  extends Promise<PostCategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostCategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostCategoryPreviousValuesPromise>() => T;
}

export interface PostCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostCategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostCategoryPreviousValuesSubscription>() => T;
}

export interface PostPhotosConnection {
  pageInfo: PageInfo;
  edges: PostPhotosEdge[];
}

export interface PostPhotosConnectionPromise
  extends Promise<PostPhotosConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostPhotosEdge>>() => T;
  aggregate: <T = AggregatePostPhotosPromise>() => T;
}

export interface PostPhotosConnectionSubscription
  extends Promise<AsyncIterator<PostPhotosConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostPhotosEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostPhotosSubscription>() => T;
}

export interface PostCategoryPreviousValues {
  id: ID_Output;
  name: String;
  isRoot: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PostCategoryPreviousValuesPromise
  extends Promise<PostCategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  isRoot: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PostCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<PostCategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  isRoot: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PostHeroConnection {
  pageInfo: PageInfo;
  edges: PostHeroEdge[];
}

export interface PostHeroConnectionPromise
  extends Promise<PostHeroConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostHeroEdge>>() => T;
  aggregate: <T = AggregatePostHeroPromise>() => T;
}

export interface PostHeroConnectionSubscription
  extends Promise<AsyncIterator<PostHeroConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostHeroEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostHeroSubscription>() => T;
}

export interface PostCategory {
  id: ID_Output;
  name: String;
  isRoot: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PostCategoryPromise
  extends Promise<PostCategory>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  isRoot: () => Promise<Boolean>;
  posts: <T = FragmentableArray<Post>>(
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  children: <T = FragmentableArray<PostCategory>>(
    args?: {
      where?: PostCategoryWhereInput;
      orderBy?: PostCategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PostCategorySubscription
  extends Promise<AsyncIterator<PostCategory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  isRoot: () => Promise<AsyncIterator<Boolean>>;
  posts: <T = Promise<AsyncIterator<PostSubscription>>>(
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  children: <T = Promise<AsyncIterator<PostCategorySubscription>>>(
    args?: {
      where?: PostCategoryWhereInput;
      orderBy?: PostCategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PostCategoryConnection {
  pageInfo: PageInfo;
  edges: PostCategoryEdge[];
}

export interface PostCategoryConnectionPromise
  extends Promise<PostCategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostCategoryEdge>>() => T;
  aggregate: <T = AggregatePostCategoryPromise>() => T;
}

export interface PostCategoryConnectionSubscription
  extends Promise<AsyncIterator<PostCategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostCategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostCategorySubscription>() => T;
}

export interface PostHeroSubscriptionPayload {
  mutation: MutationType;
  node: PostHero;
  updatedFields: String[];
  previousValues: PostHeroPreviousValues;
}

export interface PostHeroSubscriptionPayloadPromise
  extends Promise<PostHeroSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostHeroPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostHeroPreviousValuesPromise>() => T;
}

export interface PostHeroSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostHeroSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostHeroSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostHeroPreviousValuesSubscription>() => T;
}

export interface AggregateHotelPhoto {
  count: Int;
}

export interface AggregateHotelPhotoPromise
  extends Promise<AggregateHotelPhoto>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHotelPhotoSubscription
  extends Promise<AsyncIterator<AggregateHotelPhoto>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PostHeroPreviousValues {
  id: ID_Output;
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  isImage?: Boolean;
  isStored?: Boolean;
  mimeType?: String;
  size?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PostHeroPreviousValuesPromise
  extends Promise<PostHeroPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  cdnUrl: () => Promise<String>;
  uuid: () => Promise<String>;
  isImage: () => Promise<Boolean>;
  isStored: () => Promise<Boolean>;
  mimeType: () => Promise<String>;
  size: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PostHeroPreviousValuesSubscription
  extends Promise<AsyncIterator<PostHeroPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  cdnUrl: () => Promise<AsyncIterator<String>>;
  uuid: () => Promise<AsyncIterator<String>>;
  isImage: () => Promise<AsyncIterator<Boolean>>;
  isStored: () => Promise<AsyncIterator<Boolean>>;
  mimeType: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HotelEdge {
  node: Hotel;
  cursor: String;
}

export interface HotelEdgePromise extends Promise<HotelEdge>, Fragmentable {
  node: <T = HotelPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HotelEdgeSubscription
  extends Promise<AsyncIterator<HotelEdge>>,
    Fragmentable {
  node: <T = HotelSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Post {
  id: ID_Output;
  title: String;
  mdContents: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PostPromise extends Promise<Post>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  mdContents: () => Promise<String>;
  author: <T = UserPromise>() => T;
  category: <T = PostCategoryPromise>() => T;
  tags: <T = FragmentableArray<Tag>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  hero: <T = PostHeroPromise>() => T;
  photos: <T = PostPhotosPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PostSubscription
  extends Promise<AsyncIterator<Post>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  mdContents: () => Promise<AsyncIterator<String>>;
  author: <T = UserSubscription>() => T;
  category: <T = PostCategorySubscription>() => T;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  hero: <T = PostHeroSubscription>() => T;
  photos: <T = PostPhotosSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FavoriteConnection {
  pageInfo: PageInfo;
  edges: FavoriteEdge[];
}

export interface FavoriteConnectionPromise
  extends Promise<FavoriteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FavoriteEdge>>() => T;
  aggregate: <T = AggregateFavoritePromise>() => T;
}

export interface FavoriteConnectionSubscription
  extends Promise<AsyncIterator<FavoriteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FavoriteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFavoriteSubscription>() => T;
}

export interface PostPhotosSubscriptionPayload {
  mutation: MutationType;
  node: PostPhotos;
  updatedFields: String[];
  previousValues: PostPhotosPreviousValues;
}

export interface PostPhotosSubscriptionPayloadPromise
  extends Promise<PostPhotosSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostPhotosPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostPhotosPreviousValuesPromise>() => T;
}

export interface PostPhotosSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostPhotosSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostPhotosSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostPhotosPreviousValuesSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface PostPhotosPreviousValues {
  id: ID_Output;
  name?: String;
  cdnUrl?: String;
  uuid?: String;
  count?: Int;
  isImage?: Boolean;
  isStored?: Boolean;
  size?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PostPhotosPreviousValuesPromise
  extends Promise<PostPhotosPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  cdnUrl: () => Promise<String>;
  uuid: () => Promise<String>;
  count: () => Promise<Int>;
  isImage: () => Promise<Boolean>;
  isStored: () => Promise<Boolean>;
  size: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PostPhotosPreviousValuesSubscription
  extends Promise<AsyncIterator<PostPhotosPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  cdnUrl: () => Promise<AsyncIterator<String>>;
  uuid: () => Promise<AsyncIterator<String>>;
  count: () => Promise<AsyncIterator<Int>>;
  isImage: () => Promise<AsyncIterator<Boolean>>;
  isStored: () => Promise<AsyncIterator<Boolean>>;
  size: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Contact {
  id: ID_Output;
  name: String;
  email: String;
  tel: String;
  title: String;
  reference?: String;
  description: String;
  isReplied: Boolean;
  replyMessage?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ContactPromise extends Promise<Contact>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  tel: () => Promise<String>;
  title: () => Promise<String>;
  reference: () => Promise<String>;
  description: () => Promise<String>;
  isReplied: () => Promise<Boolean>;
  replyMessage: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ContactSubscription
  extends Promise<AsyncIterator<Contact>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  tel: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  reference: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  isReplied: () => Promise<AsyncIterator<Boolean>>;
  replyMessage: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserPhoto {
  id: ID_Output;
  name: String;
  cdnUrl: String;
  uuid: String;
  isImage: Boolean;
  isStored: Boolean;
  mimeType: String;
  size: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPhotoPromise extends Promise<UserPhoto>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  cdnUrl: () => Promise<String>;
  uuid: () => Promise<String>;
  isImage: () => Promise<Boolean>;
  isStored: () => Promise<Boolean>;
  mimeType: () => Promise<String>;
  size: () => Promise<Int>;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPhotoSubscription
  extends Promise<AsyncIterator<UserPhoto>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  cdnUrl: () => Promise<AsyncIterator<String>>;
  uuid: () => Promise<AsyncIterator<String>>;
  isImage: () => Promise<AsyncIterator<Boolean>>;
  isStored: () => Promise<AsyncIterator<Boolean>>;
  mimeType: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Int>>;
  user: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateArea {
  count: Int;
}

export interface AggregateAreaPromise
  extends Promise<AggregateArea>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAreaSubscription
  extends Promise<AsyncIterator<AggregateArea>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProfileSubscriptionPayload {
  mutation: MutationType;
  node: Profile;
  updatedFields: String[];
  previousValues: ProfilePreviousValues;
}

export interface ProfileSubscriptionPayloadPromise
  extends Promise<ProfileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProfilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProfilePreviousValuesPromise>() => T;
}

export interface ProfileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProfileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProfileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProfilePreviousValuesSubscription>() => T;
}

export interface AggregateTag {
  count: Int;
}

export interface AggregateTagPromise
  extends Promise<AggregateTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProfilePreviousValues {
  id: ID_Output;
  firstName?: String;
  lastName?: String;
  passportNo: String;
  address?: String;
  tel?: String;
  subscriptionEmail?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProfilePreviousValuesPromise
  extends Promise<ProfilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  passportNo: () => Promise<String>;
  address: () => Promise<String>;
  tel: () => Promise<String>;
  subscriptionEmail: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProfilePreviousValuesSubscription
  extends Promise<AsyncIterator<ProfilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  passportNo: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  tel: () => Promise<AsyncIterator<String>>;
  subscriptionEmail: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RoomConnection {
  pageInfo: PageInfo;
  edges: RoomEdge[];
}

export interface RoomConnectionPromise
  extends Promise<RoomConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RoomEdge>>() => T;
  aggregate: <T = AggregateRoomPromise>() => T;
}

export interface RoomConnectionSubscription
  extends Promise<AsyncIterator<RoomConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RoomEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRoomSubscription>() => T;
}

export interface User {
  id: ID_Output;
  email?: String;
  auth0UserId?: String;
  omiseCustomerId?: String;
  role?: ROLE;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  auth0UserId: () => Promise<String>;
  omiseCustomerId: () => Promise<String>;
  role: () => Promise<ROLE>;
  avatar: <T = UserPhotoPromise>() => T;
  posts: <T = FragmentableArray<Post>>(
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  profile: <T = ProfilePromise>() => T;
  favorites: <T = FragmentableArray<Favorite>>(
    args?: {
      where?: FavoriteWhereInput;
      orderBy?: FavoriteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  bookings: <T = FragmentableArray<Booking>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  reviews: <T = FragmentableArray<Review>>(
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  auth0UserId: () => Promise<AsyncIterator<String>>;
  omiseCustomerId: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<ROLE>>;
  avatar: <T = UserPhotoSubscription>() => T;
  posts: <T = Promise<AsyncIterator<PostSubscription>>>(
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  profile: <T = ProfileSubscription>() => T;
  favorites: <T = Promise<AsyncIterator<FavoriteSubscription>>>(
    args?: {
      where?: FavoriteWhereInput;
      orderBy?: FavoriteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  bookings: <T = Promise<AsyncIterator<BookingSubscription>>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  reviews: <T = Promise<AsyncIterator<ReviewSubscription>>>(
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregatePostPhotos {
  count: Int;
}

export interface AggregatePostPhotosPromise
  extends Promise<AggregatePostPhotos>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostPhotosSubscription
  extends Promise<AsyncIterator<AggregatePostPhotos>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReviewSubscriptionPayload {
  mutation: MutationType;
  node: Review;
  updatedFields: String[];
  previousValues: ReviewPreviousValues;
}

export interface ReviewSubscriptionPayloadPromise
  extends Promise<ReviewSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReviewPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReviewPreviousValuesPromise>() => T;
}

export interface ReviewSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReviewSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReviewSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReviewPreviousValuesSubscription>() => T;
}

export interface AggregatePostCategory {
  count: Int;
}

export interface AggregatePostCategoryPromise
  extends Promise<AggregatePostCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostCategorySubscription
  extends Promise<AsyncIterator<AggregatePostCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReviewPreviousValues {
  id: ID_Output;
  rating: Float;
  description: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ReviewPreviousValuesPromise
  extends Promise<ReviewPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  rating: () => Promise<Float>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReviewPreviousValuesSubscription
  extends Promise<AsyncIterator<ReviewPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  rating: () => Promise<AsyncIterator<Float>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HotelPhotoConnection {
  pageInfo: PageInfo;
  edges: HotelPhotoEdge[];
}

export interface HotelPhotoConnectionPromise
  extends Promise<HotelPhotoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HotelPhotoEdge>>() => T;
  aggregate: <T = AggregateHotelPhotoPromise>() => T;
}

export interface HotelPhotoConnectionSubscription
  extends Promise<AsyncIterator<HotelPhotoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HotelPhotoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHotelPhotoSubscription>() => T;
}

export interface Favorite {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FavoritePromise extends Promise<Favorite>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  hotels: <T = HotelPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FavoriteSubscription
  extends Promise<AsyncIterator<Favorite>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  hotels: <T = HotelSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CountryEdge {
  node: Country;
  cursor: String;
}

export interface CountryEdgePromise extends Promise<CountryEdge>, Fragmentable {
  node: <T = CountryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CountryEdgeSubscription
  extends Promise<AsyncIterator<CountryEdge>>,
    Fragmentable {
  node: <T = CountrySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RoomSubscriptionPayload {
  mutation: MutationType;
  node: Room;
  updatedFields: String[];
  previousValues: RoomPreviousValues;
}

export interface RoomSubscriptionPayloadPromise
  extends Promise<RoomSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RoomPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RoomPreviousValuesPromise>() => T;
}

export interface RoomSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RoomSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RoomSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RoomPreviousValuesSubscription>() => T;
}

export interface BookingEdge {
  node: Booking;
  cursor: String;
}

export interface BookingEdgePromise extends Promise<BookingEdge>, Fragmentable {
  node: <T = BookingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookingEdgeSubscription
  extends Promise<AsyncIterator<BookingEdge>>,
    Fragmentable {
  node: <T = BookingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RoomPreviousValues {
  id: ID_Output;
  name: String;
  roomType?: ROOM_TYPE;
  price?: Float;
  people?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RoomPreviousValuesPromise
  extends Promise<RoomPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  roomType: () => Promise<ROOM_TYPE>;
  price: () => Promise<Float>;
  people: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RoomPreviousValuesSubscription
  extends Promise<AsyncIterator<RoomPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  roomType: () => Promise<AsyncIterator<ROOM_TYPE>>;
  price: () => Promise<AsyncIterator<Float>>;
  people: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RoomPhotoEdge {
  node: RoomPhoto;
  cursor: String;
}

export interface RoomPhotoEdgePromise
  extends Promise<RoomPhotoEdge>,
    Fragmentable {
  node: <T = RoomPhotoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RoomPhotoEdgeSubscription
  extends Promise<AsyncIterator<RoomPhotoEdge>>,
    Fragmentable {
  node: <T = RoomPhotoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RoomPhoto {
  id: ID_Output;
  name: String;
  cdnUrl: String;
  uuid: String;
  count: Int;
  isImage: Boolean;
  isStored: Boolean;
  size: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RoomPhotoPromise extends Promise<RoomPhoto>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  cdnUrl: () => Promise<String>;
  uuid: () => Promise<String>;
  count: () => Promise<Int>;
  isImage: () => Promise<Boolean>;
  isStored: () => Promise<Boolean>;
  size: () => Promise<Int>;
  room: <T = RoomPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RoomPhotoSubscription
  extends Promise<AsyncIterator<RoomPhoto>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  cdnUrl: () => Promise<AsyncIterator<String>>;
  uuid: () => Promise<AsyncIterator<String>>;
  count: () => Promise<AsyncIterator<Int>>;
  isImage: () => Promise<AsyncIterator<Boolean>>;
  isStored: () => Promise<AsyncIterator<Boolean>>;
  size: () => Promise<AsyncIterator<Int>>;
  room: <T = RoomSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregatePostHero {
  count: Int;
}

export interface AggregatePostHeroPromise
  extends Promise<AggregatePostHero>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostHeroSubscription
  extends Promise<AsyncIterator<AggregatePostHero>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateFavorite {
  count: Int;
}

export interface AggregateFavoritePromise
  extends Promise<AggregateFavorite>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFavoriteSubscription
  extends Promise<AsyncIterator<AggregateFavorite>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagSubscriptionPayload {
  mutation: MutationType;
  node: Tag;
  updatedFields: String[];
  previousValues: TagPreviousValues;
}

export interface TagSubscriptionPayloadPromise
  extends Promise<TagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValuesPromise>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface Room {
  id: ID_Output;
  name: String;
  roomType?: ROOM_TYPE;
  price?: Float;
  people?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RoomPromise extends Promise<Room>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  roomType: () => Promise<ROOM_TYPE>;
  price: () => Promise<Float>;
  people: () => Promise<Int>;
  photos: <T = FragmentableArray<RoomPhoto>>(
    args?: {
      where?: RoomPhotoWhereInput;
      orderBy?: RoomPhotoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  hotel: <T = HotelPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RoomSubscription
  extends Promise<AsyncIterator<Room>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  roomType: () => Promise<AsyncIterator<ROOM_TYPE>>;
  price: () => Promise<AsyncIterator<Float>>;
  people: () => Promise<AsyncIterator<Int>>;
  photos: <T = Promise<AsyncIterator<RoomPhotoSubscription>>>(
    args?: {
      where?: RoomPhotoWhereInput;
      orderBy?: RoomPhotoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  hotel: <T = HotelSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RoomPhotoPreviousValues {
  id: ID_Output;
  name: String;
  cdnUrl: String;
  uuid: String;
  count: Int;
  isImage: Boolean;
  isStored: Boolean;
  size: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RoomPhotoPreviousValuesPromise
  extends Promise<RoomPhotoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  cdnUrl: () => Promise<String>;
  uuid: () => Promise<String>;
  count: () => Promise<Int>;
  isImage: () => Promise<Boolean>;
  isStored: () => Promise<Boolean>;
  size: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RoomPhotoPreviousValuesSubscription
  extends Promise<AsyncIterator<RoomPhotoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  cdnUrl: () => Promise<AsyncIterator<String>>;
  uuid: () => Promise<AsyncIterator<String>>;
  count: () => Promise<AsyncIterator<Int>>;
  isImage: () => Promise<AsyncIterator<Boolean>>;
  isStored: () => Promise<AsyncIterator<Boolean>>;
  size: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RoomPhotoSubscriptionPayload {
  mutation: MutationType;
  node: RoomPhoto;
  updatedFields: String[];
  previousValues: RoomPhotoPreviousValues;
}

export interface RoomPhotoSubscriptionPayloadPromise
  extends Promise<RoomPhotoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RoomPhotoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RoomPhotoPreviousValuesPromise>() => T;
}

export interface RoomPhotoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RoomPhotoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RoomPhotoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RoomPhotoPreviousValuesSubscription>() => T;
}

export interface ContactEdge {
  node: Contact;
  cursor: String;
}

export interface ContactEdgePromise extends Promise<ContactEdge>, Fragmentable {
  node: <T = ContactPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContactEdgeSubscription
  extends Promise<AsyncIterator<ContactEdge>>,
    Fragmentable {
  node: <T = ContactSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PostEdge {
  node: Post;
  cursor: String;
}

export interface PostEdgePromise extends Promise<PostEdge>, Fragmentable {
  node: <T = PostPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostEdgeSubscription
  extends Promise<AsyncIterator<PostEdge>>,
    Fragmentable {
  node: <T = PostSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProfile {
  count: Int;
}

export interface AggregateProfilePromise
  extends Promise<AggregateProfile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProfileSubscription
  extends Promise<AsyncIterator<AggregateProfile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

export type Long = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Advantage",
    embedded: false
  },
  {
    name: "AdvantageIcon",
    embedded: false
  },
  {
    name: "Area",
    embedded: false
  },
  {
    name: "Booking",
    embedded: false
  },
  {
    name: "Contact",
    embedded: false
  },
  {
    name: "Country",
    embedded: false
  },
  {
    name: "Favorite",
    embedded: false
  },
  {
    name: "Hotel",
    embedded: false
  },
  {
    name: "HotelPhoto",
    embedded: false
  },
  {
    name: "Post",
    embedded: false
  },
  {
    name: "PostCategory",
    embedded: false
  },
  {
    name: "PostHero",
    embedded: false
  },
  {
    name: "PostPhotos",
    embedded: false
  },
  {
    name: "Profile",
    embedded: false
  },
  {
    name: "ROLE",
    embedded: false
  },
  {
    name: "ROOM_TYPE",
    embedded: false
  },
  {
    name: "Review",
    embedded: false
  },
  {
    name: "Room",
    embedded: false
  },
  {
    name: "RoomPhoto",
    embedded: false
  },
  {
    name: "Tag",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "UserPhoto",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
